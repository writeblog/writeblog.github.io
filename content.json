{"meta":{"title":"搅拌糖","subtitle":"搅拌糖","description":"种一棵树最好的时间是十年前，其次是现在","author":"搅拌糖","url":"https://jiaobantang.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-11-25T08:06:26.911Z","updated":"2019-11-25T08:06:26.911Z","comments":true,"path":"404.html","permalink":"https://jiaobantang.github.io/404.html","excerpt":"","text":"404 Not Found **很抱歉，您访问的页面不存在** 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2020-01-01T13:32:44.438Z","updated":"2020-01-01T13:32:44.438Z","comments":true,"path":"projects/index.html","permalink":"https://jiaobantang.github.io/projects/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-01-01T10:51:14.166Z","updated":"2020-01-01T10:51:14.166Z","comments":true,"path":"about/index.html","permalink":"https://jiaobantang.github.io/about/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2020-01-01T10:51:42.929Z","updated":"2020-01-01T10:51:42.929Z","comments":true,"path":"categories/index.html","permalink":"https://jiaobantang.github.io/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2019-11-25T08:02:20.204Z","updated":"2019-11-25T08:02:20.204Z","comments":true,"path":"tags/index.html","permalink":"https://jiaobantang.github.io/tags/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2020-01-02T01:38:39.392Z","updated":"2020-01-02T01:38:39.392Z","comments":true,"path":"friends/index.html","permalink":"https://jiaobantang.github.io/friends/index.html","excerpt":"","text":"各位大佬想交换友链的话可以在下方留言，必须要有名称、头像链接、和至少一个标签哦～ 名称： 搅拌糖头像： http://cdn.treelo.xin/avatar.png网址： https://writeblog.github.io/标签： PHP Go 爱心控"}],"posts":[{"title":"photo-map:一款Web站点的地图相册","slug":"photo-map","date":"2019-06-09T11:00:38.000Z","updated":"2020-01-01T13:34:41.030Z","comments":true,"path":"2019/06/09/photo-map/","link":"","permalink":"https://jiaobantang.github.io/2019/06/09/photo-map/","excerpt":"","text":"github运行站点 我想的是记录一些日子，一些足迹我是一颗蒲公英，在飘着，落脚扎根。在这里渲染一个点，星星满满。总有一天，想去都去，该看都看。我记录着，我扩散着,能留下一点，在创造一点.…你好 陌生人这一刻，不为别的，你来都来了，看都看了，你也可以去部署啊，部署后也传播给你的朋友，能贡献代码那就更感谢你了。希望你生活快乐◕‿- 感谢Leaflet用于基础地图交互Leaflet.Photo用于渲染图片位置Leaflet.ChineseTmsProviders用于各种地图样式layui用于前端交互viewerjs用于查看图片高德地图用于获取位置信息googleauthenticator用于谷歌身份验证器验证webp-convert用于压缩图为webp格式 建议留给留言区","categories":[{"name":"Coding","slug":"Coding","permalink":"https://jiaobantang.github.io/categories/Coding/"},{"name":"Web","slug":"Coding/Web","permalink":"https://jiaobantang.github.io/categories/Coding/Web/"}],"tags":[{"name":"地图相册","slug":"地图相册","permalink":"https://jiaobantang.github.io/tags/%E5%9C%B0%E5%9B%BE%E7%9B%B8%E5%86%8C/"}]},{"title":"Hexo博客Material-X主题个性化","slug":"themes-custom","date":"2019-05-12T11:22:52.000Z","updated":"2020-01-01T13:24:25.598Z","comments":true,"path":"2019/05/12/themes-custom/","link":"","permalink":"https://jiaobantang.github.io/2019/05/12/themes-custom/","excerpt":"Hexo博客Material-X主题个性化","text":"Hexo博客Material-X主题个性化 文章列表扭七扭八 在主题目录下/ayout/_partial/post.ejs里添加class=’banner’1&lt;article class=\"post reveal banner&lt;%= (post.title) ? \"\" : \"no-title\" %&gt;\"&gt; 在主题目录/layout/_partial/footer.ejs里引入js文件1&lt;script type=\"text/javascript\" src=\"/cool/banner.js\"&gt;&lt;/script&gt; 添加抖动元素(块级) 将以下代码添加至主题目录/source/less/_base.less文件下123456789101112131415161718192021222324.shake:hover &#123; transition: all 0.3s ease;&#125;@-webkit-keyframes spaceboots &#123; 0% &#123; -webkit-transform: translate(2px, 1px) rotate(0deg); &#125; 10% &#123; -webkit-transform: translate(-1px, -2px) rotate(-1deg); &#125; 20% &#123; -webkit-transform: translate(-3px, 0px) rotate(1deg); &#125; 30% &#123; -webkit-transform: translate(0px, 2px) rotate(0deg); &#125; 40% &#123; -webkit-transform: translate(1px, -1px) rotate(1deg); &#125; 50% &#123; -webkit-transform: translate(-1px, 2px) rotate(-1deg); &#125; 60% &#123; -webkit-transform: translate(-3px, 1px) rotate(0deg); &#125; 70% &#123; -webkit-transform: translate(2px, 1px) rotate(-1deg); &#125; 80% &#123; -webkit-transform: translate(-1px, -1px) rotate(1deg); &#125; 90% &#123; -webkit-transform: translate(2px, 2px) rotate(0deg); &#125; 100% &#123; -webkit-transform: translate(1px, -2px) rotate(-1deg); &#125;&#125;.shake:hover,.shake:focus &#123; -webkit-animation-name: spaceboots; -webkit-animation-duration: 0.8s; -webkit-transform-origin:50% 50%; -webkit-animation-iteration-count: infinite; -webkit-animation-timing-function: linear;&#125; 使用方法在标签元素class类中添加shake添加血小板 live2d资源目录添加至主图目录/source下 在主题目录/layout/_partial/head.ejs文件中引入live2dcss文件12&lt;!-- 血小板--&gt;&lt;link rel=\"stylesheet\" href=\"/live2d/css/live2d.css\" /&gt; 在主题目录/layout/_partial/footer.ejs文件中添加以下代码123456789101112131415&lt;!-- 血小板 --&gt;&lt;div id=\"landlord\"&gt; &lt;div class=\"message\" style=\"opacity:0\"&gt;&lt;/div&gt; &lt;canvas id=\"live2d\" width=\"560\" height=\"500\" class=\"live2d\"&gt;&lt;/canvas&gt; &lt;div class=\"hide-button\"&gt;隐藏&lt;/div&gt;&lt;/div&gt;&lt;!-- 血小板--&gt;&lt;script type=\"text/javascript\"&gt; var message_Path = '/live2d/'&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"/live2d/js/live2d.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"/live2d/js/message.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; loadlive2d(\"live2d\", \"/live2d/model/xiaoban/model.json\");&lt;/script&gt; 为了移动端更好的阅读效果，请将以下代码添加至主题目录/source/less/_footer.less文件下123456789101112131415161718192021@media (max-width: @on_phone) &#123; #footer&#123; background-color:transparent; padding-bottom: 180px ; &#125; #landlord&#123; width: 200px; height: 170px; .message&#123; width: 200px; left: 80px; top: 15px; &#125; &#125; #live2d&#123; width: 200px; height: 170px; bottom: -80px; left: 43px; &#125;&#125; 添加页面点击小心心特效,文本输入特效、运行时间 将’https:/jiaobantang.github.io/cool/clicklove.js’另存在主题目录/source/下 将’https:/jiaobantang.github.io/cool/cooltext.js’另存在主题目录/source/下 将’https:/jiaobantang.github.io/cool/sitetime.js’另存在主题目录/source/下 修改sitetime.js参数 在主题目录/layout/_partial/footer.ejs文件中引入1234&lt;!-- 点击特效，输入特效 运行时间 --&gt;&lt;script type=\"text/javascript\" src=\"/cool/cooltext.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"/cool/clicklove.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"/cool/sitetime.js\"&gt;&lt;/script&gt; 在主题目录/layout/_partial/footer.ejs文件中上方添加1&lt;div id=\"sitetime\"&gt;&lt;/div&gt;","categories":[{"name":"Coding","slug":"Coding","permalink":"https://jiaobantang.github.io/categories/Coding/"},{"name":"Web","slug":"Coding/Web","permalink":"https://jiaobantang.github.io/categories/Coding/Web/"}],"tags":[{"name":"Cool","slug":"Cool","permalink":"https://jiaobantang.github.io/tags/Cool/"}]},{"title":"PHPer-浅层次的代码优化","slug":"php-coding3","date":"2019-04-02T08:49:26.000Z","updated":"2020-01-02T09:37:45.468Z","comments":true,"path":"2019/04/02/php-coding3/","link":"","permalink":"https://jiaobantang.github.io/2019/04/02/php-coding3/","excerpt":"","text":"说在前面代码优化是一个持续不断的过程，养成一个好的编码习惯，善用一些PHP的语法糖，让我们的代码看起来更好维护更不容易出错，这本身就是一种优化。还有一种就是对代码的可读性再做一次优化，让代码更好维护。 if的使用技巧if的使用技巧之 “给定初始值”来看一段代码 123456if(1 == $orderState)&#123; $orderTitle = \"已预定\";&#125;else&#123; $orderTitle = \"已售出\";&#125;return $orderTitle; 给定初始值之后，我们可以写成这样，少了一层else 12345$orderTitle = '已售出';if(1 == $orderState)&#123; $orderTitle = '已预定';&#125;return $orderTitle; if的使用技巧之 “用 &amp;&amp; 替换 if” 123 if(!isset($newpwd[6]))&#123; $message = '密码长度不足';&#125; 可以替换成 1!isset($newpwd[6]) &amp;&amp; $message = '密码长度不足'; if的使用技巧之“三元运算符替换if” 12345if(empty($_post['action']))&#123; $action = 'default';&#125;else&#123; $action = $_POST['action'];&#125; 也可以替换成 1$action = (empty($_post['action']))? 'default' : $_post['action']; 也可以把三元运算符简写成 1$action = $_post['action']?:'default'; if的使用技巧之 “去掉多此一举的if”这个函数是判断一个年份是否是闰年，如果是返回ture否则返回false 1234567function isLeapYear($year)&#123; if(($year % 4 == 0 &amp;&amp; $year % 100 != 0) || ($year % 400 == 0))&#123; return true; &#125;else&#123; return false; &#125;&#125; 类似于这种判断一个条件是否为真，为真返回ture为假返回false的时候，我们可以直接返回这个条件就可以了 123function isLeapYear($year)&#123; return ($year % 4 == 0 &amp;&amp; $year % 100 != 0) || ($year % 400 == 0);&#125; 改进“else if”123456789if('你'==$sortname)&#123; $sortid = 1;&#125;else if('还'==$sortname)&#123; $sortid = 2;&#125;else if('好'==$sortname)&#123; $sortid = 3;&#125;else if('吗'==$sortname)&#123; $sortid = 4;&#125; 可以用switch来改造多层的判断 1234567891011121314switch($sortname)&#123; case'你': $sortid = 1; break; case'还': $sortid = 2; break; case'好': $sortid = 3; break; case'吗': $sortid = 4; break;&#125; 表驱动法替代“else if”上面那个例子用switch似乎让代码变多了，但看起来更简洁了，如果你还不爽，那下面。。。在PHP里面数组可以理解为一个hash表 1234567$sortTable = [ '你'=&gt;1, '还'=&gt;2, '好'=&gt;3, '吗'=&gt;4];$sortid = $sorTable[$sortname]; 循环语句的几个要点 要写无限循环时，用while(true)表示无限循环，别用for。特定情况下(发邮件、采集网页)要加延时(sleep)循环体内尽可能不用函数或更消耗资源的调用foreach代替while和for循环(PHP)避免空循环只做一件事，尽可能短，控制在50行以内循环嵌套限制在3曾以内 使用更精悍短小的代码 函数的最佳最大长度时50-150行代码函数参不超过7个短小函数更容易理解也方便修改只做一件事情的函数更易于复用短小的函数测试更方便 中间结果赋值给变量$str = ‘this_is_a_test’;$humpstr = implode(‘’,array_map(‘ucfirst’,explode(‘_’,$str)));你觉得这样写好不好呢？我以为这样很cool，一行就搞定，实际上这样写并不好，乍一看不好理解，另外还不好调试。那怎么改造这种代码呢？把中间结果赋值给变量 1234$str = 'this_is_a_test';$words = explode('_',$str);$uWords = array_map('ucfirst',$words);$humpstr = implode('',$uWords); 复杂的逻辑表达式做成布尔函数123if(!$hasone &amp;&amp; 1==$ddisfirst &amp;&amp; ''==$litpic &amp;&amp;empty($litpicname))&#123; $litpicname = GetImageMapDD($iurl,$cfg_ddimg_width);&#125; 你像这样四个条件并在一起满足的条件下才会执行下面的代码，是不是会很难理解，所以复杂的逻辑表达式做成布尔函数，就是把它给切开 12345$emptyPic = ( ''==$litpic &amp;&amp;empty($litpicname);$validFirstPic = (!$hasone &amp;&amp; 1==$ddisfirst &amp;&amp; '');if($emptyPic &amp;&amp; $validFirstPic)&#123; $litpicname = GetImageMapDD($iurl,$cfg_ddimg_width);&#125; 永远不要复制粘贴雷同的代码 相同的代码放在一起让以后修改更轻松可以让全局的统计和过滤器等实现方便可复用的带参函数是解决雷同代码的好方法","categories":[{"name":"Coding","slug":"Coding","permalink":"https://jiaobantang.github.io/categories/Coding/"}],"tags":[{"name":"Coding","slug":"Coding","permalink":"https://jiaobantang.github.io/tags/Coding/"}]},{"title":"PHPer-语法糖","slug":"php-coding2","date":"2019-04-02T07:49:26.000Z","updated":"2020-01-02T08:32:14.324Z","comments":true,"path":"2019/04/02/php-coding2/","link":"","permalink":"https://jiaobantang.github.io/2019/04/02/php-coding2/","excerpt":"","text":"PHP语法糖就是PHP一些小的语法技巧计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是方便程序员使用 1、echo 的逗号和点号1234$foo = 'hello';$bar = 'world';echo $foo.$bar;echo $foo,$bar; 2、逗号优于点号echo是PHP的语言结构，用逗号是依次输出变量，点号连接操作会占用内存… 3、用$i+=1代替$i=$i+1、$i++、++$i额…你就知道效率高就行了 4、用isset代替strlenPHP语言里有一些东西看起来像函数，实际上是语言结构，语言结构要比普通函数的优先级高，也会更快，PHP常见的语言结构有： 1234567891011echo()print()die()isset()unset()include(),include_once()require(),require_once()array()list()empty()evel() 所以说能用到这些语言结构时，就尽量不要用函数如： 1234$subject = 'jiaobantang';if(strlen($subject)&lt;=8) echo '哈哈';//换成if(！isset($subject)[8] echo '哈哈'; 5、用strtr代替str_replace 6、PHP用yield实现协程yield会保存当前程序运行的状态我们写一个函数xrange()函数提供和PHP的内置函数range()一样的功能*///循环输出一个0到10000的数组,这个大数组实在内存中被真实构建的 123456789101112foreach(range(0,10000) as $number)&#123; echo $number;&#125;//但如果我想节省内存，每次在这个基础上加1就行了，这个时候我们就可以用协程来实现function xrange($start,$end,$step = 1)&#123; for($i = $start;$i &lt;= $end; $i += $step)&#123; yield $i; &#125;&#125;foreach (xrange(1,10000) as $num)&#123; echo $num,\"\\n\";&#125; 7、用“[]”定义数组8、用**进行幂运算9、用“…”定义变长参数数组12345#变长参数 不依赖 func_get_args()function addAll(...$nums)&#123; return array_sum($nums);&#125;echo addAll(1,2,4,5,6,7) 10、函数赋值默认参数：+运算符1234567# 本用法特别适用于给函数赋值默认参数function getDivHtml($params)&#123; $params += [ 'height'=&gt;'200px' ] print_r($params);&#125; 11、??运算符 123456789#三元运算符$userName = isset($_GET['username']) ? $_GET['username'] : 'nobody';#这种情况下可以简写成$userName =$_GET['username'] ?? 'nobody';12、比较运算符$num1 = $num2&lt;=&gt;$num3;#如果$num2&gt;$num3,$num1 = 1#如果$num2==$num3,$num1 = 0#如果$num2&lt;$num3,$num1 = -1 13、神奇的evaleval() 可以动态的执行任何PHP代码…","categories":[{"name":"Coding","slug":"Coding","permalink":"https://jiaobantang.github.io/categories/Coding/"}],"tags":[{"name":"Coding","slug":"Coding","permalink":"https://jiaobantang.github.io/tags/Coding/"}]},{"title":"PHPer-我所认可的PSR规范","slug":"php-coding","date":"2019-04-02T06:49:26.000Z","updated":"2020-01-02T07:18:04.170Z","comments":true,"path":"2019/04/02/php-coding/","link":"","permalink":"https://jiaobantang.github.io/2019/04/02/php-coding/","excerpt":"","text":"PSR-1 基础编码规范概括 PHP 代码文件必须 以 &lt;?php 长标签 或 &lt;?= 短输出标签； PHP 代码文件 必须 以 不带 BOM 的 UTF-8 编码； 命名空间以及类 必须 符合 PSR 的自动加载规范 这意味着每个类都独立为一个文件，并且至少在一个层次的命名空间内 类的命名 必须 遵循StudlyCaps 大写开头的驼峰命名规范； 类中的常量所有字母都 必须 大写，单词间用下划线分隔；类的属性命名 可以 遵循： 大写开头的驼峰式 ($StudlyCaps) 小写开头的驼峰式 ($camelCase) 下划线分隔式 ($under_score) 方法名称 必须 符合 camelCase 式的小写开头驼峰命名规范。PSR-2 编码风格规范 每行的字符数 应该 软性保持在 80~120 之间 每个namespace命名空间声明语句和use声明语句块后面，必须插入一个空白行。 类的开始花括号（{） 必须 写在类声明后自成一行，结束花括号（}）也 必须 写在类主体后自成一行。 方法的开始花括号（{） 必须 写在函数声明后自成一行，结束花括号（}）也 必须 写在函数主体后自成一行。 类的属性和方法 必须 添加访问修饰符（private、protected 以及 public），abstract 以及 final 必须 声明在访问修饰符之前，而 static 必须 声明在访问修饰符之后。 控制结构的关键字后 必须 要有一个空格符，而调用方法或函数时则不要有空格。 控制结构的开始花括号（{） 必须 写在声明的同一行，而结束花括号（}） 必须 写在主体后自成一行。 控制结构的开始左括号后和结束右括号前，都 一定不可 有空格符。 1234567891011121314151617181920212223242526272829303132&lt;?phpnamespace Vendor\\Package;use FooInterface;use BarClass as Bar;use OtherVendor\\OtherPackage\\BazClass;class Foo extends Bar implements FooInterface&#123; public function sampleMethod($a, $b = null) &#123; if ($a === $b) &#123; bar(); &#125; elseif ($a &gt; $b) &#123; $foo-&gt;bar($arg1); &#125; else &#123; BazClass::bar($arg2, $arg3); &#125; try &#123; // try 主体 &#125; catch (FirstExceptionType $e) &#123; // catch 主体 &#125; catch (OtherExceptionType $e) &#123; // catch 主体 &#125; &#125; final public static function bar() &#123; // 方法体 &#125;&#125;","categories":[{"name":"Coding","slug":"Coding","permalink":"https://jiaobantang.github.io/categories/Coding/"},{"name":"PSR","slug":"Coding/PSR","permalink":"https://jiaobantang.github.io/categories/Coding/PSR/"}],"tags":[{"name":"Coding","slug":"Coding","permalink":"https://jiaobantang.github.io/tags/Coding/"}]},{"title":"糖糖日签","slug":"tangsign","date":"2019-03-24T06:45:21.000Z","updated":"2020-01-03T08:53:18.237Z","comments":true,"path":"2019/03/24/tangsign/","link":"","permalink":"https://jiaobantang.github.io/2019/03/24/tangsign/","excerpt":"","text":"更新计划延迟添加选色卡(2019/4/22) 本次更新(2019/4/8)字体使用CDN，更换主页风格，引入三言展示免责声明：“糖糖日签”所用到的字体，均下载自正规渠道，未获得商用授权。“糖糖日签”所用到的字体均为个人使用，未曾用于营利性的活动当中。 本次更新(2019/3/1/24)更新内容：可更换字体，新浪图床外链[项目地址]糖糖日签","categories":[{"name":"Coding","slug":"Coding","permalink":"https://jiaobantang.github.io/categories/Coding/"},{"name":"Web","slug":"Coding/Web","permalink":"https://jiaobantang.github.io/categories/Coding/Web/"}],"tags":[{"name":"糖糖日签","slug":"糖糖日签","permalink":"https://jiaobantang.github.io/tags/%E7%B3%96%E7%B3%96%E6%97%A5%E7%AD%BE/"},{"name":"日签","slug":"日签","permalink":"https://jiaobantang.github.io/tags/%E6%97%A5%E7%AD%BE/"}]},{"title":"Javascript高级","slug":"javascript-advanced","date":"2018-12-25T06:13:18.000Z","updated":"2020-01-03T08:56:31.875Z","comments":true,"path":"2018/12/25/javascript-advanced/","link":"","permalink":"https://jiaobantang.github.io/2018/12/25/javascript-advanced/","excerpt":"","text":"官方文档 请回答以下问题Java和JavaScript什么关系？ 1最初的 JavaScript 名为 LiveScript，后来因为 Sun Microsystem 的 Java 语言的兴起和广泛使用，Netscape 出于宣传和推广的考虑，将它的名字从最初的 LiveScript 更改为 JavaScript——尽管两者之间并没有什么共同点。这便是之后混淆产生的根源。 ES6听说过吗？和JavaScript什么关系？ES2015听说过吗？都是什么关系？ 1ES6是JavaScript的第六版,因为在2015年发布,所以也称ES2015 如何把变量转成数字？转成布尔？转成字符串？ 12345转数字parseInt：如果前几个字符是数字可以转成数字。Number：将整体转成数字。。。。。其他的我觉得没什么好转的 使用 Number() 和 parseInt 转数字时的区别？ 1如上... var 和 let 干什么用的？什么区别？ 12345都是定义变量的var 可以定义局部变量和全局变量let 可以定义快级变量（只在大括号中生效的变量）、局部变量和全局变量一般在函数外部多使用var 来定义变量，在函数和循环内多试用let来定义变量var 支持变量提升，let不支持 在一个函数中，如果定义变量时没有添加 var 会出现什么情况？ 1如果在函数中定义变量时没有写 var 或者 let 那么变量会变成全局变量。 什么是内存泄漏？ 1应该当作垃圾回收结果无法被释放，导致一直占用内存。这种行为被成为内存泄露 什么是块级作用域？如何定义块级作用域的变量？ 1在大大括号内的，一般用let定义块级变量 你需要带着问题，看下面的内容 什么是运算符短路？有什么用？说出JS中你用过的数据类型？编写一个使用 let 定义变量和使用 var 定义变量不同点的案例。for .. in 和 for .. of 的区别？用途？forEach 的用途？请问 arguments 是干什么用的？它代表什么？什么是匿名函数？应用场景？this 代表什么？什么是箭头函数？有什么用途？this 在箭头函数和普通函数中的区别是什么？call 和 apply 的功能是什么？有什么区别？如何开启严格模式？请说出至少一个严格模式与普通模式的区别？什么是闭包？闭包有什么特点？有什么用？什么是垃圾回收机制？什么是内存泄漏？在什么情况下会出现内存泄漏？什么是OOP？OOP的三大特性？什么是多态？什么是原型链？对象如何访问原型对象？构造函数如何访问原型对象？什么是构造函数？在JS中如何基于原型(prototype)实现面向对象？ES6中的OOP中 super 是干什么用的？ES6中的继承需要注意什么？ 介绍 数据类型 类型转换转数字parseInt：如果前几个字符是数字可以转成数字。Number：将整体转成数字。 123var num = '123abc';console.log( parseInt(num) ); // 123console.log( Number(num) ); // NaN (Not a Number) 转字符串12console.log( 100 + 100 + '100abc'); // 200100abcconsole.log( '' + 100 + 100 + '100abc'); // 100100100abc 变量定义变量：var 和 let。 定义常量：const。 var可以定义 局部变量 和 全局变量。 1234var name; // 全局变量function abc() &#123; var age; // 局部变量&#125; 意外的全局变量。如果在函数中定义变量时没有写 var 或者 let 那么变量会变成全局变量。 123456function abc() &#123; age = 10 // 全局变量&#125;abc()console.log( age ) // 10 let可以定义块级变量、 局部变量 和 全局变量。 let 可以定义块级变量（只在大括号中生效的变量） 示例1：let 和 var 的区别 12345678910for(let i=0;i&lt;10;i++) &#123; &#125;console.log( i ) // undefinedfor(var i=0;i&lt;10;i++) &#123; &#125;console.log( i ) // 10 示例2：使用 var 时无论，调用数组中第几个函数，输出的结果都是10 123456789var funs = []for(var i=0;i&lt;10;i++) &#123; funs[i] = function() &#123; console.log( i ) &#125;&#125;funs[3](); //10funs[4](); //10funs[5](); //10 使用 let 时的效果： 123456789var funs = []for(let i=0;i&lt;10;i++) &#123; funs[i] = function() &#123; console.log( i ) &#125;&#125;funs[3](); // 3funs[4](); // 4funs[5](); // 5 短路运算符我们可以使用 &amp;&amp; 和 || 实现短路操作。 &amp;&amp; ： 连接多个语句，当语句1为真是执行语句2. ||：连接多个语句，当语句1为假时执行语句2. 可以用短路运算符来实现一些简写，比如，有时我们获取到一个变量，不知道它的值是什么，但我们希望无论如何它都是一个数字，至少是个0，我们就可以写： 12// 如果 a 是假就得到0var a = a || 0 12// 如果 o 存在就调用 o.nameo &amp;&amp; o.name() 循环 除了 while、do…while、for 之外，我们还可以使用： 在循环数组时，我们可以使用 for...of 、for...in、forEach。 循环对象时，我们可以使用 for...in。 12345678910111213141516let arr = ['a','b','c','d','e']// 循环得到值for(let i of arr) &#123; console.log(i) // abcde&#125;// 循环得到下标for(let i in arr) &#123; console.log(i) // 01234&#125;// 循环得到下标和值arr.forEach((v,k)=&gt;&#123; console.log(k,v) // 0a1b2c3d4e&#125;) 函数arguments在函数中可以使用 arguments 获取函数在调用时的参数数组。 123456function abc() &#123; console.log( arguments.length ) // 2 , 获取参数的数量 console.log( arguments[0] ) // tom ,第一个参数值 console.log( arguments[1] ) // jack ,第二个参数值&#125;abc('tom','jack') 匿名函数匿名函数可以用来隔绝一段作用域。 有时我们需要在一个现有的项目中添加新的代码，这时当我们添加变量、函数时就有可能出现和原来系统中变量名、函数名冲突的情况，为了避免我们的代码和原代码中出现命名冲突的情况，我们就可以把我们的代码放到一个匿名函数中，然后调用这个匿名函数，这样我们所写的代码都只在这个匿名函数内生效，就不会影响其它代码了。 有两种写法，来调用匿名函数得到一段独立的作用域： 1234567891011(function()&#123; // 这里的代码不影响外面的作用域 &#125;)()!function()&#123; // 这里的代码不影响外面的作用域 &#125;() 箭头函数箭头函数是匿名函数的一种简写方式。 123456789// 普通函数setTimeout(function()&#123; console.log( 'hello' )&#125;, 1000)// 箭头函数setTimeout(()=&gt;&#123; console.log( 'hello' )&#125;, 1000) 比如以下代码运行的结果是不同的： 123456789101112131415var age = 20function abc() &#123; this.age = 10 setTimeout(function()&#123; console.log( this.age ) // 20 &#125;, 1000) setTimeout(()=&gt;&#123; console.log( this.age ) // 10 &#125;, 1000)&#125;abc() call/applycall 和 apply 的功能相同：使一个函数归属于一个对象来调用。 12345678function abc() &#123; console.log( this.age )&#125;var o = &#123; age:10&#125;abc(); // 独立调用时 this.age 不存在abc.call(o); // 10 ， abc 函数归属于 o 这个对象来调用，这时 this.age 指的就是 o 对象中的 age。 call 和 apply 的区别是参数形式不同： 12345678function abc(a,b) &#123; console.log( this.age )&#125;var o = &#123; age:10&#125;abc.call(o, 10, 20); // 10 ， 20 对应 a, b 两个参数abc.apply(o, [10,20]); // [10,20] 数组中的对应 a,b 两个参数 严格模式以下代码在严格模式下会报错： 1234567'use strict' // 严格模式function abc() &#123; age = 'tom' // 报错&#125;abc(); 闭包 以下代码就是一个闭包，它制作了一个 id 变量，这个变量不会马上销毁，会一直存在，并且不能被外部随意修改，只能通过闭包内修改。 123456789101112// 定义闭包function getId() &#123; var id = 0; return function() &#123; return id++; &#125;&#125;// 获取一个自增的IDvar id = getId()console.log( id() ) //0console.log( id() ) //1console.log( id() ) //2 内存泄漏 循环引用当 DOM 对象和 JS 对象互相引用时，会导致两个对象在该销毁时都无法销毁。 比如下面的 el 和 o 这两个对象都是局部变量，在函数执行之后就应该销毁，但因为两个对象互相引用，所以导致函数执行之后也无法销毁： 原型链原型链：所有的对象都会继承自一个原型对象，这个原型对象又会继承自一个原型对象，一层一层直到最顶层继承自 null，这样的链就是原型链。 构造函数：生成对象的函数。 访问原型对象 对象中通过 __proto__ 访问原型对象。 构造函数中通过 prototype 访问原型对象。 基于原型链的面向对象JS 在实现面向对象编程时传统的方法是基于原型链+构造函数。 12345678910111213141516// 定义一个类function Person(name, age) &#123; this.name = name this.age = age&#125;// 在原型对象上添加方法Person.prototype.setName = function(name) &#123; this.name = name&#125;Person.prototype.getName = function() &#123; return this.name&#125;// 生成对象var p1 = new Person('tom',10)console.log( p1.getName() ); // tom JS 中实现面向对象编程的原则： 属性定义到构造函数中 方法定义到原型对象上（避免每个对象都拷贝一份函数） ES6 中的面向对象ES6 中提供了 class 可以实现面向对象。 12345678910111213141516171819class Person&#123; // 构造函数 constructor(name,age) &#123; this.name = name this.age = age &#125; getName() &#123; return this.name &#125; setName(name) &#123; this.name = name &#125;&#125;var p1 = new Person('tom',10)console.log( p1.getName() ) // tom 继承在原型统的 JS 中我们使用原型对象实现继承，在 ES6 中我们可以使用 extends 实现类的继承。 1234567891011121314151617181920class Person&#123; // 构造函数 constructor(name,age) &#123; this.name = name this.age = age &#125; getName() &#123; return this.name &#125; setName(name) &#123; this.name = name &#125;&#125;// 继承自 Personclass Boy extends Person &#123; &#125; super在继承时，如果子类中定义了构造函数，那么在构造函数中必须要调用 super 方法来调用父类的构造函数。 ~jsclass Person{ // 构造函数 constructor(name,age) { this.name = name this.age = age } getName() { return this.name } setName(name) { this.name = name }}// 继承自 Personclass Boy extends Person { constructor(name, age) { // 调用父类的构造函数 super(name, age) }}","categories":[{"name":"Coding","slug":"Coding","permalink":"https://jiaobantang.github.io/categories/Coding/"},{"name":"JS","slug":"Coding/JS","permalink":"https://jiaobantang.github.io/categories/Coding/JS/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jiaobantang.github.io/tags/JavaScript/"}]},{"title":"PHPer-OOP","slug":"php-oop","date":"2018-12-19T05:49:52.000Z","updated":"2020-01-03T08:43:49.973Z","comments":true,"path":"2018/12/19/php-oop/","link":"","permalink":"https://jiaobantang.github.io/2018/12/19/php-oop/","excerpt":"面向对象编程 PHP中的编程方式只有两种面向过程和面向对象。 OOP(Object Oriented Programming,面向对象程序设计)是一种高级的计算机编程架构。让我们更好的组织项目中的代码，目前所有流行的PHP框架都是面向对象的方式编写的，熟练掌握面&gt; 向对象是PHP开发者的必备技能。","text":"面向对象编程 PHP中的编程方式只有两种面向过程和面向对象。 OOP(Object Oriented Programming,面向对象程序设计)是一种高级的计算机编程架构。让我们更好的组织项目中的代码，目前所有流行的PHP框架都是面向对象的方式编写的，熟练掌握面&gt; 向对象是PHP开发者的必备技能。 面向对象中的概念比较多，这里列出来的只是一小部分以下需熟练掌握: 类和对象 命名空间 类的自动加载 魔术方法 静态成员 继承类和对象类类 （ Class ） 是 面 向 对 象 程 序 设 计 （ OOP ， Object Oriented Programming）实现信息封装的基础。类是一种用户定义类型，也称类类型。每个类包含数据说明和一组操作数据或传递消息的函数。类的实例称为对象 面向对象编程有三大特性：封装、继承、多态。其中封装的意思就是说所有的代码必须要写在一个类中，不能把代码写到类的外部。不过因为 PHP 并不是一个纯粹的面向对象的语言，PHP 中即支持面向过程的语法又支持面向对象的语法，所以在 PHP 中即使把代码写到类的外部也是可以的。 定义类的方法 123456class 类&#123; #类由属性和方法构成 //常量 //属性 //方法&#125; 说明： 一般类名的首字母大写，比如class Blog 一般一个类写在一个文件中，文件名和类名相同,比如Blog.php文件中定义class blog 在类中只包含，常量，属性。访问类型属性和方法包含三种访问类型public protected private public (公有的、默认的):所有的内部成员或外部成员都可以访问（读和写）这个类成员(包括成员属性和成员方法) private (私有的):被定义为private的成员，对于同一个类里的所有成员是可见的，即没有访问限制；但对于该类的外部代码是不允许改变甚至读操作，对于该类的子类，也不能访问private修饰的成员 protected(受保护的):被修饰为protected的成员不能被该类的外部代码访问。但是对于该类的子类有访问权限，可以进行属性、方法的读及写操作，该子类的外部代码包括其的子类都不具有访问其属性和方法的权限。 对象对象是对类的实例化 类只是描述了要实现的功能，类中的代码要想执行，需要实例化出对象来，通过对象我们才能真正执行类中的代码。 类就相当于图纸定义了类的功能，对象是根据图纸制作出来的具体的实体。一个类可以创建出任意多个对象： 类的实例化： 12new 类名;#例 $blog = new Blog; 例化类的对象之后，我们就可以使用对象来访问类中的属性和方法了。 说明： 在其他文件中如想使用类，首先需要先引入类文件 类中的属性和方法都要使用 $对象-&gt; 访问 类中的 常量 和 静态成员 直接使用 类名:: 来访问 注意:一个类能创建多个对象,一个对象只能是一个类创建的 $this在类的外部我们使用 -&gt; 来访问类中的属性和方法： 1$blog-&gt;title='haha' 那么，在类的内部应该如何访问类中的属性和方法呢？使用$this 在类中如何访问常量和静态成员呢？使用self:: 命名空间我们开实际大型项目时，我们可能需要引入很多第三方的类库，那么这些类库中有没有可能出现同名的类呢？肯定会有！为了解决类同名的问题，PHP 中引入了 ”命名空间“ 机制。 namespace我们可以使用namespace声明一个命名空间，然后在它后面定义的类就都属于这个命名空间，比如，我们声明一个叫做 test 的命名空间，并在空间中定义一个类： 1234namespace text;class Student&#123;....&#125; 注意：namespace必须是文件中的第一行代码。这个 Student 类现在就属于 test 这个命名空间中，这时当我们再要使用这个类时，必须要在前面加上命名空间： 1$student = new test\\Student; 注意：命名空间使用 \\ 符号。这样不同类包中的同名的类就不会冲突了，因为不同类包的命名空间都不相同，比如：腾讯公司的 Log 可能是属于 Tencent 命名空间下，阿里公司的类包可能是属于 Ali 命名空间下，即使它们的类名都叫 Log 也不会冲突： 12345// 实例化阿里 Log 类$log = new Ali\\Log;// 实例化腾讯 Log 类$log1 = new Tencent\\Log; 这就是命名空间的用途。 命名空间也可以有子命名空间： 12345&lt;?php// 三级命名空间namespace Ali\\Domain\\Beijing;class Log &#123; ... &#125; 在实际工作当中，我们一般声明命名空间和类文件所在的目录相同。比如：在 app/controllers 目录下有一个 BlogController 类：app/controllers/BlogController.php 123456&lt;?phpnamespace app\\controllers;class BlogController&#123;&#125; 总结总结： 为了避免类同名，所以引入命名空间 命名空间和类文件所在目录相同 namespace 必须是文件中的第一行代码 use现在每次实例化一个类时，需要写很长的类名（包含命名空间），如何能简化呢？方法一：在同一个命名空间下，可以省略命名空间方法二：使用 use同一命名空间下在使用同一个命名空间里面的类时，可以省略命名空间，直接写类名。 比如，我们再创建一个 models/User 类： models/User.php 123456&lt;?phpnamespace app\\models;class User&#123;&#125; 因为这个类和同目录下的 Blog 类都在同一个命名空间 app\\models 下，所以可以省略命名空间： 12345678910111213&lt;?phpnamespace app\\models;class User&#123; public function getBlog() &#123; // 引入类文件 require('./Blog.php'); $blog = new Blog; &#125;&#125; 总结：同一命名空间下的类，在使用时可以省略命名空间，但记住还是需要引入类文件的。use当使用不同命名空间中的类时，需要在实例化时加上命名空间，这会导致需要输入的类名比较长： 1$blog = app\\controllers\\BlogController 如果想要简化可以使用 use 语句。 use 的功能是在文件的开始引入一个命名空间下的类，引入之后就可以直接使用类名来使用这个类了： 123use app\\controllers\\BlogController;$blog = new BlogController; 在引入时也可以为类起别名： 123use app\\controllers\\BlogController as BC;$blog = new BC; 示例、创建 testUse.php 文件 123456789101112&lt;?phprequire('app/controllers/BlogController.php');require('app/models/Blog.php');use app\\controller\\BlogController as BC;use app\\models\\Blog;$blog1 = new BC;$blog2 = new BC;$blog3 = new BC;$blogModel = new Blog; 类文件的自动加载有没有发现我们每次在使用一个类时都要先使用 require 引入类文件，在一个大的项目中我们需要使用数十个类，如果每次都要引入数十个类文件，实在是太麻烦了。 为了解决这个问题，PHP 为我们提供了类的自动加载机制，有了这个机制，我们就可以直接使用类了，然后 PHP 会自动引入相应的类文件，我们就不用一个一个的手动引入了。 spl_autoload_registerPHP 中提供了一个 spl_autoload_register 函数，该函数可以让我们注册一个函数到 PHP 中，然后当我们使用一个类时，如果 PHP 找不到这个类，就会调用我们注册的函数来加载相应的类文件。 1使用一个类 =&gt; 找不到？=&gt; 调用注册的函数 =&gt; 加载类文件 =&gt; 找到了 =&gt; 类可以使用了 示例、注册一个类加载函数： 123456// 定义加载函数function load($class)&#123; &#125;// 注册 load 函数spl_autoload_register('load'); 代码说明： 定义了一个 load 函数 注册到 PHP 中 当我们使用一个不存在的类时，load 函数会被调用，参数就是类的名字（包含命名空间） 示例、创建一个 testLoad 文件 testLoad.php 123456789&lt;?phpfunction load($class)&#123; echo '我们需要加载：' . $class;&#125;spl_autoload_register('load');// 实例化$blog = new app\\models\\Blog; 启动 PHP 服务器 php -S localhost:9999 然后浏览器中运行代码： 因为我们没有加载类文件，所以报错显示找不到类类，但同时也可以看到我们的 load 函数被执行了。 总结：当一个不存在的类被使用时，我们注册的函数会被自动调用。 魔术方法在 OOP 中有一套特殊的方法，叫做魔术方法，它们的特点是： 方法名以两个下划线开头（__） 在某一时刻自动被调用 接下来我们来学习其中最重要的一个： __construct其他的魔术方法在文末： 构造方法__construct 是一个魔术方法，它在实例化一个类对象时会被调用，经常用来初始化类的数据，我们一般叫做：“构造方法” 自动调用演示1、构造方法在实例化对象时被调用 每当使用 new 实例化一个类对象时，类中的构造方法就会被调用一次： Boy.php 1234567891011121314&lt;?phpclass Boy&#123; public $name; public function __construct() &#123; echo 'hello world '; &#125;&#125;$boy = new Boy; // hello world;$boy1 = new Boy; // hello world; 初始数据构造方法经常用来初始化类中的数据。我们通过在构造方法中添加参数来接收初始的数据。 Boy.php 12345678910111213141516&lt;?phpclass Boy&#123; public $name; public function __construct($name) &#123; $this-&gt;name = $name; &#125; public function hello() &#123; echo 'hello '.$name; &#125;&#125; 当一个类的构造方法上有参数时，在实例化这个类的对象时，必须要使用小括号依次设置参数值： 12$boy = new Boy('小明');$boy1 = new Boy('三毛'); 示例、统计一个类所拥有的对象的总数。 要统计一个类被实例化的总数，原理很简单：每次实例化一个对象时就把计数加1。我们可以把代码写在构造方法中，因为每次使用 new 创建对象时，构造函数都会被调用。 12345678910111213141516171819&lt;?phpclass Boy&#123; // 保存总的对象数 public static $count=0; public function __construct() &#123; // 每次加1 self::$count++; &#125;&#125;$boy = new Boy; $boy1 = new Boy;// 打印总的记录数echo Boy::$count; 静态成员在类中我们可以使用 static 定义静态成员。可以是静态属性也可以是静态的方法： 123456789101112&lt;?phpclass Boy&#123; public static $count=0; public static function getCount() &#123; return self::$count; &#125;&#125;echo Boy::$count; 代码说明： 在方法或者属性前添加 static 来定义静态成员 在类外部使用 类名:: 来访问静态成员，如 Boy::$count , Boy::getCount() 在类内部使用 self:: 访问静态成员，如：self::$count 静态成员和普通成员区别？ 静态成员：静态成员属于类，无论有多少个对象，值只有一个。 普通成员：普通成员属于具体的对象，每个对象拥有自己的属性值。 比如：学生姓名就应该是一个普通属性，属于每一个同学，因为每个同学有自己的名字。而学生总人数这个属性就应该是一个静态属性，它属于“学生”这个大类，并不是某一个具体学生的属性。 同理，像身高、体重、性别这些都应该是普通属性，而平均年龄，最大年龄等应该属于静态属性。 继承继承是面向对象三大特性之一，通过继承我们可以避免编写重复的代码，让我们的代码管理起来更加有组织有层次。 继承：一个类可以继承自另一个类，继承之后就拥有了那个类中所有非私有的属性和方法。 extendsPHP 中使用 extends 实现继承。 12345678910111213141516171819&lt;?phpclass People&#123; public $name; public function eat() &#123; echo 'eat'; &#125;&#125;class Boy extends People&#123; &#125;$boy = new Boy;$boy-&gt;name = '小明';$boy-&gt;eat(); // eat 代码说明 一个类只能继承自一个父类（单继承），不能同时继承多个类 Boy 继承自 People ，所以 Boy 的类中就拥有了 name 属性和 eat 方法 避免重复代码实际应用中，我们经常把多个类共有的方法制作成一个父类，然后让这个类继承自这个父类，这样相同的代码就只需要写一次： 动态绑定继承时有一个特性：“动态绑定”，在实际应用中经常会用到，接下来我们来学习一下到底什么是动态绑定。 首先我们先来看一段代码： 123456789101112131415161718192021&lt;?php class People&#123; public $name='tom'; public function getName() &#123; echo $this-&gt;name; &#125;&#125;class Boy extends People&#123; public $name='jack';&#125;$boy = new Boy;$people = new People;$boy-&gt;getName();$people-&gt;getName(); 请问：最后两行分别输出的是什么？ $boy-&gt;getName() 输出的是 “jack”。 $people-&gt;getName() 输出的是 “tom”。 它们执行的代码是一样的，都是 echo $this-&gt;name ，为什么输出的结果却不同呢？ 要知道原因，就要先搞清楚 $this 到底代表什么？ $this 代表实例化的那个对象。 当 new People 时，$this 就代表 People 类的对象，所以得到的是 People 类中的 name。 当new Boy 时， $this 代表 Boy 类的对象，所以得到的就是 Boy 类中的 name。 总结：$this 的值是动态的，所以叫做动态绑定，即：$this-&gt;name 的值到底是什么我们在编写类时并不确定，只有在使用 new 实例化对象时才能确定。 练习：以下代码的输出结果是？ 123456789101112131415161718192021222324252627&lt;?phpclass A&#123; $name = 'tom'; public function getName() &#123; echo $this-&gt;name; &#125;&#125;class B extends A&#123; &#125;class C extends A&#123; $name = 'jack';&#125;class D extends C&#123; $name = 'ali';&#125;$b = new B;$b-&gt;getName();$c = new C;$c-&gt;getName();$d = new D;$c-&gt;getName(); TraitTrait：特质，可以让我们不使用继承就可以在多个类中复用方法的机制。 定义特质使用 trait 来定义一个特质，特质中只能定义方法： 12345trait Fly&#123; public function fly()&#123;&#125; ...&#125; 使用特质定义了特质之后，我们就可以在一个类中使用 use 来引入这个特质，引入了特质之后，这个类就拥有了这个特质中的方法。 1234567class Superman&#123; use Fly;&#125;$s = new Superman;$s-&gt;fly(); 总结： trait 可以用来向一个类中添加方法 不用继承就可以实现方法的复用 魔术方法： 构造函数：__construct(): 构造函数是类中的一个特殊函数，当我们使用new关键字实例化对象时，相当于调用了类的构造函数。 析构函数：__destruct(): ①析构函数在对象被销毁释放之前自动调用； ②析构函数不能带有任何的参数； ③析构函数常用于对象使用完以后，释放资源，关闭资源等。 __set($key,$value): 给类私有属性赋值时自动调用，调用是给方法传递两个参数：需要设置的属性名、属性值 __get($key): 给获取类私有属性时自动调用，调用是给方法传递一个参数：需要获取的属性名 isset($key): 外部使用isset()函数检测私有属性时，自动调用。 类外部使用isset();检测私有属性，默认检测不到（false） 所以，我们可以使用isset()函数，在自动调用时，返回内部检测结果 __unset($key): 外部使用unset()函数删除私有属性时，自动调用； __clone: ① 当使用clone关键字，克隆对象时，自动调用clone函数 ② __clone()函数类似于克隆是使用的构造函数，可以给新克隆对象赋初值 ③ 克隆函数里面的$this指的是新克隆的对象 __tostring() 当使用echo等输出语句，直接打印对象时,调用 echo $zhangsan;那么， 可以指定tostring()方法的返回值，返回值需要是字符串。 则使用echo函数打印时，将会打印出tostring()函数返回的字符串 __call() 调用类中未定义或未公开的方法时，会自动执行__call()方法，自动执行时，会给call方法传递两个参数： ① 调用的方法名 ② （数组）调用的方法的参数列表 __autoload() ① 这是唯一一个不在类中使用的魔术方法② 当实例化一个不存在的类时，自动调用这个魔术方法③ 调用时，会自动给autoload()传递一个参数：实例化的类名所以，可以实现 使用这个方法，自动加载类文件的功能：$zhangdan=new Person(“战三”);//本文件没有Person类，会自动执行autoload加载person.class.php文件复制代码 sleep()：① 当执行对象串行化（将对象通过一系列操作，转化为字符串的过程，称为串行化）的时候，会自动执行sleep()函数；② __sleep()函数要求返回一个数组，数组中的值，就是可以串行化的属性， 不在数组中的属性，不能被串行化。 wakeup()① 当反串行化对象时，自动调用wakeup()方法；②自动调用时，用于给反串行化产生的新对象的属性，进行重新赋值；","categories":[{"name":"Coding","slug":"Coding","permalink":"https://jiaobantang.github.io/categories/Coding/"},{"name":"PHP","slug":"Coding/PHP","permalink":"https://jiaobantang.github.io/categories/Coding/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://jiaobantang.github.io/tags/PHP/"},{"name":"OOP","slug":"OOP","permalink":"https://jiaobantang.github.io/tags/OOP/"}]},{"title":"PHP-PDO","slug":"mysql-pdo","date":"2018-12-12T00:37:51.000Z","updated":"2020-01-03T09:08:57.818Z","comments":true,"path":"2018/12/12/mysql-pdo/","link":"","permalink":"https://jiaobantang.github.io/2018/12/12/mysql-pdo/","excerpt":"PDOPDO（PHP 数据对象），是 PHP 中的一个扩展库，用来操作数据库 使用 PDO 之前首先要确保 PHP 中安装了 PDO 这个扩展，我们可以使用以下两种方法来查看本地的 PHP 中是否安装了 PDO 扩展，同时要打开pdo_mysql扩展。","text":"PDOPDO（PHP 数据对象），是 PHP 中的一个扩展库，用来操作数据库 使用 PDO 之前首先要确保 PHP 中安装了 PDO 这个扩展，我们可以使用以下两种方法来查看本地的 PHP 中是否安装了 PDO 扩展，同时要打开pdo_mysql扩展。 使用 phpinfo() 函数并在浏览器查看 在命令行中执行 php -m 查看是否有 pdo 扩展 PDO 中一共提供了三个类PDO 类：PDO 的核心，主要负责连接数据、发送 SQL 语句等。PDOStatement 类：主要用于解析结果集、实现预处理、事务等。PDOException 类：主要用来代表 PDO 的异常。 PDO的基本用法连接数据库创建 PDO 的对象，就是连接数据库 1234567891011try&#123; //连接数据库 $pdo = new \\PDP('mysql:host=IP地址;dbname=数据库名;','用户名','密码'); //设置编码 $pdo -&gt;exec(\"set names utf8\");&#125;catch(PDOException $e)&#123; var_dump($e-&gt;getMessage()); exit();&#125; 断开连接123$pdo = null;#或unset($pdo); exec() 方法当要执行 insert、update、delete 等非 select 的语句时可以使用 PDO 类中提供的 exec 方法： 1234$pdo-&gt;exec($sql);//1.成功时返回受影响的条数，有可能值为 0。//2. 失败时返回 false。//3.在判断是否执行成功时应该使用 === 来判断。 query() 方法当要执行 select 从表中获取数据时，需要使用以下类方法 123$pdo-&gt;query($sql);//1. 如果执行成功返回 PDOStatement 类的对象。//2. 如果失败返回 false 执行完 select 语句之后，PDO 会把数据保存到PDOStatement 类对象中返回，我们还需要使用这个类中的几个方法来获取数据 1234567891011$stmt = $pdo-&gt;query($sql);$stmt-&gt;rowCount(); // 返回记录数$stmt-&gt;columnCount(); // 返回列数$stmt-&gt;fetch([数据样式]); // 取出一条记录（执行一次取出一条）$stmt-&gt;fetchAll([数据样式])// 取出所有记录//数据样式// PDO::FETCH_ASSOC : 返回关联数组(较常用)//PDO::FETCH_BOTH ：返回混合数组//PDO::FETCH_NUM ：返回索引数组//PDO::FETCH_OBJ ：返回对象//PDO::FETCH__COLUMN ：返回某一列的值 其他方法12$id = $pdo-&gt;lastInsertId() // 返回新插入的记录的 id$err =$pdo-&gt;errorInfo() // 如果失败，返回包含错误信息的数组 预处理预处理是另一种高级的执行 SQL 语句的方式。和前面学习的执行 SQL 语句的方式相比，预处理有以下两个好处➢ 执行 SQL 语句的速度更快。➢ 这种方式更加的安全（对数据过滤，防止 SQL 注入） 因为预处理有很多好处，所以我们以后尽量都使用预处理的方式来执行 SQL 语句。 使用预处理的方式执行 SQL 语句主要分为两步： 先用 prepare 预执行 SQL 语句。 绑定数据并执行 预执行 12345$sql= 'insert into test values(?,?)';//数据部分需要用？来代替，或用':字段名'来代替//$sql= 'insert into test values(:name,:age)';$stmt = $pdo-&gt;prepare($sql) 绑定数据并执行 12345678$stmt-&gt;execute([ tom, 19]);/*$stmt-&gt;execute([ :name=&gt;'tom', :age=19]);*/ 事物1234567891011121314151617//设置异常模式$pdo-&gt;setAttribute(PDO::ATTR_ERRMODE,PDO::ERRMODE_EXCEPTION);try&#123; //开启事务 $pdo -&gt;beginTransaction(); //执行的SQL语句 //提交 $pdo-&gt;commit();&#125;catch(Exception $e)&#123; //抓住try里面出现的错误，并且处理 //echo $e-&gt;getMessage(); //获取异常信息 //回滚 $pdo-&gt;rollBack();&#125; PDO属性12$pdo-&gt;setAttribute(属性名，属性值); // 设置属性值$pdo-&gt;getAttribute(属性名); // 获取属性值 属性列表PDO 中可以设置的属性非常多我们只先学习其中最常用的两个属性。获取数据模式我们可以使用 fetch 和 fetchAll 两个方法提取数据，在提供数据时可以通过参数设置提取模式：错误模式 我们在执行每个操作时，都要考虑这个操作是否成功，如果失败了我们需要做相应的错误处理 但是，目前不同的操作错误处理的默认方式又是不同的，比如，连接数据库时如果失败会抛出 PDOException 异常，而其他操作失败时会返回 false。这就导致我们需要使用不同的方式来处理错误。 我们可以通过错误模式属性，设置所有的错误模式相同，这样我们就可以写出统一的错误处理代码。","categories":[{"name":"Coding","slug":"Coding","permalink":"https://jiaobantang.github.io/categories/Coding/"},{"name":"MySQL","slug":"Coding/MySQL","permalink":"https://jiaobantang.github.io/categories/Coding/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://jiaobantang.github.io/tags/MySQL/"},{"name":"PDO","slug":"PDO","permalink":"https://jiaobantang.github.io/tags/PDO/"}]},{"title":"Docker进阶-编制、制作镜像、目录共享","slug":"docker-Advanced","date":"2018-12-05T09:18:01.000Z","updated":"2020-01-03T08:55:37.514Z","comments":true,"path":"2018/12/05/docker-Advanced/","link":"","permalink":"https://jiaobantang.github.io/2018/12/05/docker-Advanced/","excerpt":"我们下载的镜像都是官方默认的镜像，这些镜像有时无法满足我们个性化的要求，这时我们就可以自己来制作镜像。制作镜像有三种方法:","text":"我们下载的镜像都是官方默认的镜像，这些镜像有时无法满足我们个性化的要求，这时我们就可以自己来制作镜像。制作镜像有三种方法: 制作镜像1、使用docker commit 方法优点: 方便，一个指令（把一个现有的容器制作成一个镜像）缺点：没有记录制作的过程2、使用Dockerfile + docker build 指令3、本地文件系统导入模板 docker commit我们可以直接使用docker commit指令将一个容器制作成一个镜像： 1docker commit 容器名称 镜像名称：标签 dockerfile使用Dockerfile 文件制作镜像的过程：1、编写Dockerfile文件2、执行docker build指令生成镜像 1docker build -t 镜像名称：标签 Dockerfile文件所在目录 示例： 12docker build -t test:1.0 .#.表示当前目录 Dockerfile 详解我们一般可以把一个Dockerfile 文件内容分为四部分| 四部分 | 指令 || ——————– | —————————– || 基础镜像信息 | FROM （第一条指令必须是这个） || 维护者信息 | MAINTAINER || 镜像操作指令 | RUN、COPY、ADD、EXPOSE、ENV等 || 容器启动时执行的指令 | CMD、ENTRYPOINT | 指令说明 FROM：指定基础镜像镜像是一层一层的,最底层是操作系统,我们要制作镜像必须要先试用 FROM 来指定一个镜像，然后我们是在这个基础镜像的基础上制作新镜像的： 12FROM 镜像:标签#FROM alpine:3.8 MAINTAINER:指定作者名称（选填） 12FROM alpine:3.8MAINTAINER jiaobantang@126.com RUN：运行 shell 命令在制作镜像的过程中可以使用 RUN 来执行 shell 命令。如：1、在镜像中创建/php目录2、为镜像安装vim 编辑器3、设置 apk 的国内镜像源（多个指令用 &amp;&amp; 连接，如果指令太长可以使用 \\ 写到下一行中）4、更新 apk 的软件 1234567FROM alpine:3.8MAINTAINER jiaobantang@126.comRUN mkdir /phpRUN apk add vimRUN echo http://mirrors.ustc.edu.cn/alpine/v3.8/main &gt; /etc/apk/repositories &amp;&amp; \\ echo http://mirrors.ustc.edu.cn/alpine/v3.8/community &gt;&gt; /etc/apk/repositoriesRUN apk update &amp;&amp; apk upgrade COPY、ADD 复制本地文件到镜像中 1ADD/COPY 源目录 目标目录 ADD：该命令将复制指定的源目录到容器中的目标目录。 其中源目录可以是Dockerfile所在目录的一个相对路径；也可以是一个 URL；还可以是一个 tar 文件（自动解压为目录）。COPY ：当使用本地目录为源目录时，推荐使用 COPY。示例、在制作镜像时复制当前目录中的 php 目录到镜像中的 /php 目录中： 123456789FROM alpine:3.8MAINTAINER jiaobantang@126.comRUN mkdir /phpRUN apk add vimRUN echo http://mirrors.ustc.edu.cn/alpine/v3.8/main &gt; /etc/apk/repositories &amp;&amp; \\ echo http://mirrors.ustc.edu.cn/alpine/v3.8/community &gt;&gt; /etc/apk/repositoriesRUN apk update &amp;&amp; apk upgradeCOPY php /php ENV :设置环境变量。可以使用 ENV 来设置镜像中的环境变量。1ENV &lt;key&gt; &lt;value&gt; EXPOSE：暴露端口1EXPOSE &lt;port&gt; [&lt;port&gt;...] 告诉 Docker 服务端容器暴露的端口号，供互联系统使用。在启动容器时需要通过 -P，Docker 主机会自动分配一个端口转发到指定的端口。 1EXPORT 80 800 880 ENTRYPOINT容器在启动时执行的命令，一个 Dockerfile 中只能有一个 ENTRYPOINT 指令，如果写了多个，那么只有最后一个会执行。 语法有两种： 12ENTRYPOINT [&quot;命令&quot;, &quot;参数1&quot;, &quot;参数2&quot; ...]ENTRYPOINT 命令 参数1 参数2 .... 示例：在启动容器时，输出 ‘hello’ 1ENTRYPOINT [\"echo\", \"hello\"] CMD 容器在启动时执行的命令，一个 Dockerfile 中只能有一个 CMD 指令，如果写了多个，那么只有最后一个会执行。 CMD 与 ENTRYPOINT 的不同： 1、CMD 设置的命令可以被 docker run 时指令的要执行的命令覆盖，而 ENTRYPOINT 的命令不会被覆盖。 2、CMD 和 ENTRYPOINT 同时存在时，CMD 中的内容会变成 ENTRYPOINT 中指令命令的默认参数，该参数可以被 docker run 时设置的命令覆盖。 WORKDIR指定当前的工作目录。比如下面指令先切换到了 /php 目录中，之后执行的指令都是在这个目录下的操作（相对于 cd /php） 12WORKDIR /phpmkdir abc # 创建 /php/abc 目录 VOLUME创建一个可以从本地主机或其他容器挂载的挂载点，一般用来存放数据库和需要保持的数据等。格式： 1VOLUME [&quot;目录&quot;] 指定了挂载目录之后，就可以在创建容器时使用 -v 或者 --volumes-from 来指令共享挂载这些目录。 制作带扩展的 PHP 镜像创建 Dockerfile 123456789101112131415161718192021FROM php:7.2-fpm-alpineMAINTAINER \"jiaobantang@126.com\"#使用国内 apk 源RUN echo http://mirrors.ustc.edu.cn/alpine/v3.8/main &gt; /etc/apk/repositories &amp;&amp; \\ echo http://mirrors.ustc.edu.cn/alpine/v3.8/community &gt;&gt; /etc/apk/repositories &amp;&amp; \\ apk update &amp;&amp; apk upgrade# 安装依赖RUN apk add libpng-dev autoconf gcc g++ make openssl-dev##### 安装 PHP 扩展 # 安装 gd、pdo_mysql 库RUN docker-php-ext-install gd pdo_mysql sockets pcntl zip mysqli opcache# 更新 peclRUN pecl channel-update pecl.php.net# 安装 redis 扩展RUN echo -e \"\\n\\n\" | pecl install redis &amp;&amp; docker-php-ext-enable redis# 安装 yaf 扩展RUN pecl install yaf &amp;&amp; docker-php-ext-enable yaf# 安装 swoole 扩展RUN echo -e \"yes\\nyes\\n\\n\\n\\n\\n\" | pecl install swoole &amp;&amp; docker-php-ext-enable swoole# 安装 git composerRUN apk add git composer 创建镜像： 1docker build -t 镜像名:标签 . 上传镜像镜像制作好之后，我们可以吧镜像上传到docker的仓库中docker 的官方网站为注册用户提供了一个 docker 仓库，我们可以把我们自己的镜像放到 docker 官方的仓库上。 注册账号因为需要谷歌人机验证，请自行搬梯子 登陆有了自己的仓库之后，我们就可以把本地的镜像上传到仓库中给所有人使用。 1、首先需要先在本地登录 执行以下指令进行登录（需要输入账号、密码）： 1docker login 2、打标签 登录成功之后，还需要为要上传的镜像打一个标签，注意这个标签必须要以 账号/ 开头： 1docker tag 本地镜像:标签 账号/镜像名称:标签 比如，我的账号是 jiaobantang ，现在我要将本地的 php:1.0 上传到仓库中，那么首先我们对这个镜像打标签： 1docker tag php:1.0 fortheday001/php:1.0 3、上传 打完标签之后，我们就可以上传了： 1docker push 账号/镜像:标签 如： 1docker push jiaobantang/php:1.0 这个指令会将镜像上传到 jiaobantang 这个仓库中。 构建私有镜像仓库官网只可以设置一个私有仓库，多个需要RMB可以自己搭建一个私有镜像仓库 拉了镜像1docker pull registry 创建容器 1docker run --name dockerhub -d -p 绑定端口号:5000 registry 上传到私有仓库 12docker tag 镜像:标签 仓库IP:绑定端口号/镜像:标签docker push 仓库IP:绑定端口号/镜像:标签 如： 12docker tag alpine:3.8 localhost:5000/alpine:3.8docker push localhost:5000/alpine:3.8 编排为什么要使用编排当容器多时，一个一个的管理 太麻烦，所以我们可以使用编排，通过一个简单指令来管理多个容器。使用流程： 1、创建 docker-compose.yml 配置文件（yaml语法） 2、使用 docker-compose 来指令管理这个集群 创建配置文件配置文件默认使用 docker-compose.yml 做为文件名，其中使用 yaml 语法编写。yaml 语法说明： ​ a. 缩近代表子选项目，如下面的 mysql 和 php 就是 services 的子选项。​ b. - 代表有多个值（相当于数组），如下面的 ports 下就绑定了两个端口号（注意 - 后面要加空格 ） 例子：创建一个 mysql 和一个 PHP 容器，PHP依赖于mysql： 1234567891011121314151617version: '3'services: mysql: image: mysql:5.7.24 ports: - \"43306:3306\" - \"55555:3306\" environment: - MYSQL_ROOT_PASSWORD=123123 volumes: - /data:/var/mysql/data php: image: fortheday001/php depends_on: - mysql links: - mysql:mysql version：指定使用的版本，这个要和使用的 docker 的版本对应 services ：配置要启动的容器 mysql、php：启动的容器的名字，可以自定义 image：启动容器需要使用的镜像 ports：需要映射的端口号 environment：启动容器时需要设置的环境变量 volumes：需要挂载的硬盘 depends_on：依赖的容器，这一项决定了容器在启动时的顺序 links：启动容器时的连接编排指令 创建好配置文件之后，就可以使用 docker-compose 指令来管理配置文件中配置的容器了。 注意：执行指令时必须要在配置文件的同级目录中执行。 常用的指令如下： 1234docker-compose up -d # 创建所有容器并在后台运行docker-compose stop # 停止所有容器docker-compose down --volumes # 删除所有容器以及挂载的目录docker-compose ps # 查看当前这个集群中的容器的状态 目录共享我们在启动容器时，可以添加 --volumes-from 这个参数，和另一个容器共享目录。流程： 1、先在一个容器启动时使用 -v 参数设置挂载的目录（挂载之后才允许其它容器来共享） 1docker run --name abc -d -v /var/www/html fortheday001/php -v 这里并没有指定绑定到的位置，那么它会随机绑定到一个位置上（这种不能和主机共享目录） 注意：如果绑定时不指定 绑定的位置 ，那么不能和主机共享目录，只能用来容器之间共享目录。 2、其它的容器在启动时可以使用 --volumes-from 来共享 1docker run --name bcd -d --volumes-from abc fortheday001/php 扩展：可以通过 docker inspect 指令查看一个容器已经挂载的目录： docker inspect abc 查看abc容器： 123456789101112&quot;Mounts&quot;: [ &#123; &quot;Type&quot;: &quot;volume&quot;, &quot;Name&quot;: &quot;92e89eeb09791da95e9a67cc0945d531407dc5b605e818fdf2300e27d73cf5f0&quot;, &quot;Source&quot;: &quot;/var/lib/docker/volumes/92e89eeb09791da95e9a67cc0945d531407dc5b605e818fdf2300e27d73cf5f0/_data&quot;, &quot;Destination&quot;: &quot;/var/www/html&quot;, &quot;Driver&quot;: &quot;local&quot;, &quot;Mode&quot;: &quot;&quot;, &quot;RW&quot;: true, &quot;Propagation&quot;: &quot;&quot; &#125; ], 比如：我们现在有两个容器 a 、b 现在我们希望b能够共享a中的/data目录 ： 那么我们应该在启动 b 容器时添加这个参数： 1docker run --name b -d --volues-from a 镜像的名字.. 这个指令就是创建 b 容器并且和 a 容器共享目录 。 思考：那么到底共享了 a 中的哪个目录 。 答：只能共享 a 容器中挂载了的目录（启动a 时使用 -v 挂载的路径 ） 主机容器之间共享如果希望容器和主机也共享目录，那么在使用 -v 参数挂载目录时要指定要挂载的主机的目录 。 这个只能在容器之间共享 1docker run --name abc -d -v /var/www/html fortheday001/php 如果希望这个目录和主机也共享，那么必须要挂载到主机的目录上： 1docker run --name abc -d -v C:/code/html:/var/www/html fortheday001/php 进入容器/镜像的方法进入容器当我们要进入一个正在运行的容器时可以使用以下这个指令： 1docker exec -it 容器的名称 /bin/sh -it ：以交互的方式运行 /bin/sh 指令 进入镜像有时我们希望进入一个还没有创建容器的镜像，这时我们可以使用下面这个指令： 1docker run -it --rm 镜像的名字 /bin/sh 原理：创建一个临时的容器然后进入，退出时删除容器（–rm） -it ：以交互的方式运行 /bin/sh 指令–rm ：退出指令时删除容器 [mark] (参考自我的上课讲义)完！","categories":[{"name":"Coding","slug":"Coding","permalink":"https://jiaobantang.github.io/categories/Coding/"},{"name":"Docker","slug":"Coding/Docker","permalink":"https://jiaobantang.github.io/categories/Coding/Docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://jiaobantang.github.io/tags/docker/"}]},{"title":"部署nginx项目集群","slug":"docker-nginx","date":"2018-12-05T07:18:01.000Z","updated":"2020-01-03T08:56:09.662Z","comments":true,"path":"2018/12/05/docker-nginx/","link":"","permalink":"https://jiaobantang.github.io/2018/12/05/docker-nginx/","excerpt":"部署nginx项目集群","text":"部署nginx项目集群 架构 创建两个项目服务器如架构图所示，我们需要两台运行项目的容器 首先我们需要创建一个可以用来运行我们项目的容器，从图上可以看出这个容器需要连接数据库主服务器和从服务器的负载均衡，所以在创建容器时需要使用 –link 连接到两个容器。因为要运行 PHP 的代码所以我们需要使用 php:7.2-fpm-alpine 这个镜像来创建容器： 1docker run --name xxxx1 -d --link mysql13306:mysqlwrite --link haproxy:mysqlread php:7.2-fpm-alpine 安装PHP扩展PHP 官方默认的镜像中必要运行 PHP 项目必须要的扩展：如 GD 、pdo_mysql 等，所以我们在创建了容器之后需要进入容器中去，为 PHP 添加扩展。 1、进入刚创建的容器中 1docker exec -it xxxx1 /bin/sh 2、设置国内仓库为了安装的更快，首先先执行以下三个命令来设置使用国内的包管理源： 123echo http://mirrors.ustc.edu.cn/alpine/v3.8/main &gt; /etc/apk/repositoriesecho http://mirrors.ustc.edu.cn/alpine/v3.8/community &gt;&gt; /etc/apk/repositoriesapk update &amp;&amp; apk upgrade 3、安装 gd 扩展 通过查看 PHP 的镜像文档，我们找到安装扩展可以使用 docker-php-ext-install 这个命令，有了这个命令可以大大简化我们安装扩展的步骤。 安装 gd 扩展时首先要安装 libpng 这个包，否则会安装失败。 12apk add libpng-dev # 安装 libpng-dev 这个包docker-php-ext-install gd # 安装 gd 扩展 4、安装 pdo_mysql 扩展 接下来再安装 pdo_mysql 这个扩展，否则 pdo 无法操作 mysql 数据库： 1docker-php-ext-install pdo_mysql 到此安装扩展完成。 复制代码到容器安装好了扩展之后，运行我们 API 项目的基本环境就准备好了，接下来我们需要把 API 项目的代码复制到这个容器中。 在主机上 执行下面命令复制项目代码到容器： 1docker cp 主机项目目录 xxxx:/var/www/html 复制完代码之后，我们还需要设置项目中 storage 目录的权限，因为 Laravel 框架的项目要求 storage 目录必须要有写权限才能运行，而在 Linux 系统下默认是没有写权限的，所以复制完项目到容器之后，为项目分配写权限。 进入容器，然后执行 1chmod -R 777 /var/www/html 修改配置文件项目代码复制到容器中之后，我们还需要修改项目的配置文件，主要修改数据库的配置（如果用到了 Redis 也需要修改 Redis 的配置，因为这里没有考虑 Redis ，所以先不考虑）。 使用 vi 编辑器修改 config/database.php 修改数据库的主机为创建容器时 –link 进来的别名： 12345678910111213141516171819202122'mysql' =&gt; [ 'read' =&gt; [ 'host'=&gt; 'mysqlread', # MySQL 主服务器的别名 ], 'write' =&gt; [ 'host'=&gt; 'mysqlwrite', # MySQL 从服务器负载均衡的别名 ], 'driver' =&gt; 'mysql', // 'host' =&gt; env('DB_HOST', '127.0.0.1'), 'port' =&gt; env('DB_PORT', '3306'), 'database' =&gt; env('DB_DATABASE', 'forge'), 'username' =&gt; env('DB_USERNAME', 'forge'), 'password' =&gt; '123123', // 'password' =&gt; env('DB_PASSWORD', ''), 'unix_socket' =&gt; env('DB_SOCKET', ''), 'charset' =&gt; 'utf8mb4', 'collation' =&gt; 'utf8mb4_unicode_ci', 'prefix' =&gt; '', 'prefix_indexes' =&gt; true, 'strict' =&gt; true, 'engine' =&gt; null, ], 到此项目的容器就制作好了，容器中的项目已经可以正常运行起来了。 制作项目镜像经过前面的几个操作我们就已经制作了一个可以运行PHP项目的容器，接下来，我们可以把我们制作好的容器保存成为一个镜像，这样当我们需要再创建更多相同的容器时，就可以直接使用镜像创建就可以了。 制作镜像常用两种方法：docker commit 指令 和 Dockerfile 文件。这里我们使用 docker commit 这个指令来制作镜像。docker exec 可以把一个现有的容器制作成为一个镜像，语法: 1docker commit 容器名称 镜像名:标签名 所以，把我们这个 API 容器制作成镜像的指令是： 1docker commit xxxx1 xxxx:1.0 制作完之后，执行 docker images 就可以查看到制作的镜像了。 再创建一个项目容器根据我们最前面设计架构图，我们需要有两个 API 服务器，所以我们需要再创建一个 API 项目的容器，因为我们刚刚已经制作好了镜像，所以我们直接使用这个镜像就可以创建一个相同的 API 容器了： 1docker run --name xxxx2 -d --link mysql13306:mysqlwrite --link haproxy:mysqlread xxxx:1.0 nginx 负载均衡有了 API 项目的容器之后，最后我们还需要创建一个 Nginx 容器，这个容器有两个用途： 1、做为 WEB 服务器让用户来访问 2、做为负载均衡服务器转发请求到后端 API 服务器 创建容器首先，我们需要先创建一个 nginx 容器 1docker run --name xxxx_nginx -d -p 49999:80 --link xxxx1:xxxx_gate1 --link xxxx2:xxxxgate2 nginx:1.15.6-alpine 配置 nginx创建了容器之后，我们需要配置 nginx 服务器。 1、进入 nginx 容器 1docker exec -it xxxx+nginx /bin/sh 2、修改 nginx 配置文件 /etc/nginx/conf.d/default.conf 123456789101112131415161718192021222324# 定义 后端服务器， api 是这一组的名字upstream api &#123; # max_fails=3：允许失败3 次，第4次再失败就不再向这台服务器转发(健康检查) # fail_timeout：设置连接超时时间 # weight=1:设置转发的权重 server xxxx_gate1:9000 max_fails=3 fail_timeout=3s weight=1; server xxxx_gate2:9000 max_fails=3 fail_timeout=3s weight=1;&#125; server &#123; ... location / &#123; try_files $uri $uri/ /index.php?$query_string; # Laravel 框架需要添加这一项进行 url 重写，否则无法运行 &#125; ... location ~ \\.php$ &#123; fastcgi_pass api; # 要转发的后端服务器组 fastcgi_index index.php; # 指定 API 服务器上项目所在目录，注意要指定到 public 目录下(laravel框架public是根目录) fastcgi_param SCRIPT_FILENAME /var/www/html/项目目录名称/public$fastcgi_script_name; include fastcgi_params; &#125; ...&#125; 3、重启服务器 修改了配置文件之后，退出容器，重新启动相关的几个容器，然后在浏览器中访问 1http://localhost:49999 即可访问网站了。至此我们就把项目部署成集群的架构了。 [mark] (参考自我的上课讲义) 未完待续！","categories":[{"name":"Coding","slug":"Coding","permalink":"https://jiaobantang.github.io/categories/Coding/"},{"name":"Docker","slug":"Coding/Docker","permalink":"https://jiaobantang.github.io/categories/Coding/Docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://jiaobantang.github.io/tags/docker/"},{"name":"nginx","slug":"nginx","permalink":"https://jiaobantang.github.io/tags/nginx/"}]},{"title":"MySQL主,从复制与负载均衡'","slug":"docker-mysql","date":"2018-12-05T06:28:01.000Z","updated":"2020-01-03T08:55:54.867Z","comments":true,"path":"2018/12/05/docker-mysql/","link":"","permalink":"https://jiaobantang.github.io/2018/12/05/docker-mysql/","excerpt":"主从复制","text":"主从复制 流程图所用到的软件Docker＋haproxy(负载均衡)+MySQL 启动三台MySQL服务器拉取 MySQL 镜像: 1docker pull mysql:5.7 启动三个容器，并同时修改它们的MySQL配置文件，修改配置文件中的四项： –server-id:设置一个唯一的id(正整数就行,集群中id不能重复) –log-bin:启动二进制日志并设置二进制日志文件的名字 –character-set-server:设置编码 –collation-server:设置效验规则12345docker run --name mysql13306 -d -p 13306:3306 -e MYSQL_ROOT_PASSWORD=123123 mysql:5.7.24 --server-id=1 --log-bin=mysql-bin --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_cidocker run --name mysql13307 --link mysql13306:mysqlmaster -d -p 13307:3306 -e MYSQL_ROOT_PASSWORD=123123 mysql:5.7.24 --server-id=2 --log-bin=mysql-bin --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_cidocker run --name mysql13308 --link mysql13306:mysqlmaster -d -p 13308:3306 -e MYSQL_ROOT_PASSWORD=123123 mysql:5.7.24 --server-id=3 --log-bin=mysql-bin --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci 设置主服务器创建好服务器之后，我们需要首先连接主服务器并做以下设置： 1、创建复制用的账号 我们需要在主服务器上创建一个账号，然后从服务器就可以使用这个账号连接到主服务器并读取二进制文件实现数据同步。 在主服务器上执行以下 SQL 语句 1GRANT replication slave ON *.* TO 'slave'@'%' IDENTIFIED BY '111111'; 2、查看主服务器状态创建好账号之后，我们还需要查看一下当前主服务器上二进制日志的状态，在后面配置从服务器时需要使用。 执行以下 SQL 语句查看： 1show master status 注意 ： 得到这两个值之后，不要再对主服务器有任何 SQL 的写操作（否则这两个值还会变）直到从服务器配置成功。 到此主服务器配置完成，接下来我们需要配置两个从服务器。 设置从服务器在两个从服务器上执行以下三条 SQL 语句： 123456789101112stop slave; # 先停止复制功能# 设置主服务器IP、账号、密码、二日志状态 change master to master_host=\"mysqlmaster\", master_user=\"slave\", master_password=\"111111\", master_log_file=\"mysql-bin.000003\", # 这个值修改为前面主服务器的 File 值 master_log_pos=154; # 这个值修改为前面主服务器的 Position 值# 启动复制功能start slave; 查看主从状态到此已经配置成功了，我们需要在两个从服务器上执行以下 SQL 查看是否成功 1show slave status; 成功时以下两项都为 Yes ： 到此就配置完成了，现在我们向主服务器上的所有写操作都会自动同步到从服务器上。 测试配置完之后，在主服务器上新建数据库 1create database test_master_slave 然后到两个从服务器上查看会发现同样都有这个数据库： 负载均衡接下来我们需要安装并配置一个负载均衡服务器，对两台从服务器进行请求的转发。 拉取haproxy镜像首先我们要下载 haproxy 的镜像： 1docker pull haproxy:1.5.19-alpine 运行容器创建负载均衡容器 1docker run --name haproxy -d -p 13333:3306 --link mysql13307:mysql1 --link mysql13308:mysql2 haproxy:1.5.19-alpine 创建之后，发现该容器无法启动，这是因为我们还没有为它编写好配置文件，所以我们需要编写负载均衡配置文件。 配置先在本机中创建一个配置文件，文件名为 haproxy.cfg 。 1、编写配置文件 haproxy.cfg 1234567891011121314151617globaldaemonnbproc 1pidfile /usr/local/haproxy/conf/haproxy.piddefaultsmode tcpretries 2option redispatchoption abortonclosemaxconn 4096listen test1bind 0.0.0.0:3306 # 监听的端口号mode tcp # 负载均衡时使用的协议 tcp(数据库) http(web服务器)server s1 mysql1:3306 # 配置后端要转发服务器server s2 mysql2:3306 2、复制配置文件到容器中 编写好配置文件之后，我们需要把配置文件复制到容器中： 1docker cp 本地路径/haproxy.cfg haproxy:/usr/local/etc/haproxy/haproxy.cfg 3、启动容器 有了配置文件之后，我们就可以启动负载均衡的容器了。 1docker start haproxy 现在就可以通过 127.0.0.1:13333 端口连接负载均衡了。 Laravel 中配置主从接下来，我们将京西商城的 api 接口项目和数据库集群结合实现程序上的 读、写分离。 1、导入商城数据库 在主服务器上创建 jxshop 商城，并将项目中的 jxshop.sql 到主服务器执行一遍以导入商城数据库结构。 2、修改 Laravel 中的配置文件 在 mysql 中添加 read 和 write 两个数组，在这两个数组中分别设置读、写服务器的账号信息，相同的配置项可以写到数组的外面。 config/database.php 123456789101112131415161718192021'mysql' =&gt; [ 'read' =&gt; [ 'port' =&gt; '13307', ], 'write' =&gt; [ 'port' =&gt; '13306', ], 'driver' =&gt; 'mysql', 'host' =&gt; env('DB_HOST', '127.0.0.1'), // 'port' =&gt; env('DB_PORT', '3306'), 'database' =&gt; env('DB_DATABASE', 'forge'), 'username' =&gt; env('DB_USERNAME', 'forge'), 'password' =&gt; 123123, 'unix_socket' =&gt; env('DB_SOCKET', ''), 'charset' =&gt; 'utf8mb4', 'collation' =&gt; 'utf8mb4_unicode_ci', 'prefix' =&gt; '', 'prefix_indexes' =&gt; true, 'strict' =&gt; true, 'engine' =&gt; null,], [mark] (参考自我的上课讲义) 未完待续！","categories":[{"name":"Coding","slug":"Coding","permalink":"https://jiaobantang.github.io/categories/Coding/"},{"name":"Docker","slug":"Coding/Docker","permalink":"https://jiaobantang.github.io/categories/Coding/Docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://jiaobantang.github.io/tags/docker/"}]},{"title":"集群的介绍","slug":"docker-colony","date":"2018-12-04T12:22:57.000Z","updated":"2020-01-03T08:55:44.656Z","comments":true,"path":"2018/12/04/docker-colony/","link":"","permalink":"https://jiaobantang.github.io/2018/12/04/docker-colony/","excerpt":"集群的进化阶段一、起步刚开始时，网站流量比较小，所有的软件都安装在一台服务器：","text":"集群的进化阶段一、起步刚开始时，网站流量比较小，所有的软件都安装在一台服务器： 阶段二、拆分流量大了，一台电脑无法支撑，所以我们需要把每个服务单独放在一台服务器上，以提高网站的吞吐量：阶段三、横向扩展流量更大时，发现即使每个服务用一台电脑也是不够用的，这时我们需要 横向扩展 每种服务需要用到的服务器：Nginx、PHP这些服务提供的服务完全是一样的，在扩展时只需要简单的添加更多的服务器即可，而 MySQL、Redis 这些保存数据的服务不能通过简单的添加服务器来扩展，还要考虑到多台服务器的数据同步问题，后面再详细介绍。阶段四、拆分功能模块当流量再大时，我们发现只是简单的拆分服务器已不能满足要求，这时我们需要再往细了拆分：拆分功能模块，每个功能单独放到一个集群上，这就是目前非常流行的 微服务。 技术介绍负载均衡（Load Balance） 将请求转发给任一后端服务器。 转发策略：负载均衡有多种转发策略，常用的有轮询、加权轮询等方法 健康检查：通过 心跳 机制检查后端服务器是否正常运行，如果某台服务器宕机就不再向这台服务器发送请求。 软件：实现负载均衡常用的软件有lvs、haproxy、nginx 等。 高可用（High Availiablity 高可用：系统能够一直提供稳定的服务，即使服务器出现宕机的情况。 很多公司的高可用目标是4个9，也就是99.99%，这就意味着，系统的年停机时间为8.76个小时。 服务器宕机是不可避免的情况，那么我们如何才能保存系统在有机器宕机时依然能够提供服务呢？ 实现高可用的原理非常简单：提供一个备份服务器，当工作服务器宕机时，备份服务器马上替代上。 比如上面负载均衡图框架中的负载均衡服务器就存在 单点故障 问题，就是说如果负载均衡服务器宕机了，那么整个系统就无法访问了，所以为了解决单点故障我们需要为负载均衡服务器添加一个备份服务器： 常用实现高可用的软件有：keepalived 、heartbeat 等。 SESSION 共享 由于 SESSION 的原理是在服务器上保存数据，这就会导致在集群环境下出现 SESSION 丢失 的问题，这是因为在有负载均衡的集群环境中，每次请求的后端服务器可能是不同的，我们在保存 SESSION 时可能保存到了 a 服务器上，而在负载均衡轮询到其它服务器时无法读取到 SESSION 数据。 由于 SESSION 是保存在第三台服务器上的，所以当负载均衡把请求转发给另外两台服务器时就会出现获取不到 SESSION 的情况。 解决 SESSION 丢失有两种办法： 1、 SESSION 共享 将 SESSION 保存到 Redis 或者数据库中以实现共享，由于 SESSION 的使用比较频繁所以还是放在 Redis 中最好： 2、IP HASH 另一个方法是修改负载均衡的转发策略，不要使用轮询的方式，而是使用IP HASH的方式，这种方式会根据用户的IP进行HASH运算然后计算出对应的后端服务器，以后这个IP发送的所有请求都转发同这台服务器上，这样同一个用户每次访问的是同一个后台服务器，这样就可以正常使用 SESSION 了。 反向代理 反向代理服务器相当于是一个缓存服务器。 用户首先访问反向代理服务器，如果在服务器有要访问的数据的缓存数据并且没有过期就直接返回给用户，如果没有缓存数据就替用户到后端去取数据，取到数据之后缓存到本地，然后返回给用户，下次再有人访问同样的数据时直接返回缓存数据。 这种服务器常用来缓存网站中静态页面，比如：新闻详情、小说详情等不经常更新的页面。 常用软件：varnish（推荐）、squid。 CDN CDN：内容分发网络，和反向代理类似，只不过，CDN是把数据缓存在世界各地的服务器节点上，当用户访问数据时会从离他最近的服务器节点上去找，比较适用于静态资源的地域优化。比如：图片、新闻、视频、直播、音乐等。 数据库集群数据库的集群不能通过简单的扩展服务器来实现，因为数据库在集群时要考虑数据的同步、事务一致性等问题。常用的数据库集群方案有：1、主、从复制2、分库、分表3、PXC 集群 主、从复制MySQL 自带主从复制。 一主多从 适用于：读操作比较多，写操作比较少。 一个集群中只能有一个主服务器，可以有多个从服务器，对主服务器上的所有写操作都会自动同步到从服务器上： 工作原理主服务器会将所有写操作记录到 binlog（二进制日志） 中，然后从服务器会从主服务器读取这个 binlog，然后在从服务器上把 binlog 中的内容重放一遍以实现数据的同步。 读写分离在主从复制这种架构的基础上，我们的程序就可以实现 读写分离 来提供网站的性能。 读写分离：指所有的定操作都到主服务器上去执行，所有的读操作都到从服务器上去执行，这样可以在不同的服务器上执行不同的操作，以分担单台服务器的压力（注意这里主服务器存在单点故障问题，如果要解决这个问题，我们就需要实现 MySQL 主服务器的双机热备）。 多主多从 当网站写压力比较大时，我们就需要多台主服务器来分担负载，然后让它们互为主从这样就可以同步数据了，这时我们可以搭建以下结构的 MySQL 集群： 跨地址同步数据存在的问题：数据延迟由于主从复制是异步执行的，复制数据时根据系统负载、网络等多方面原因会出现从服务器复制数据的延迟问题，这就会导致新插入的数据无法马上读取的情况，这对于一些对数据一致性要求比较高的系统是无法接受的。比如，我刚刚下了一个订单并且支付成功了，可系统却一直显示未支付，此时用户一定会心慌慌担心自己的钱被骗了。 解决办法：1、使用 PXC 集群：PXC是一种 强一致性 的集群，在向一个节点插入数据时，PXC会先将这个数据同时插入到所有其它节点上去，在其它节点没有插入成功时就一直阻塞等待，直至所有其它节点都写入成功了，才会显示插入成功，否则显示插入失败。这种集群对于一些和钱相关的系统来说是很有用的。当然有利就有弊，PXC的集群的缺点就是速度慢，对强一致性要求高的场景，主要跟钱相关。 2、使用缓存服务器来减少延迟：为了即保存一致性又能保证性能，我们可以使用缓存服务器（比如 Redis ）来暂时存储数据以减少延迟。 写数据时：同时向数据库和 Redis 中写入 读数据时：先到数据库中读，如果数据库中没有再到 Redis 中读，如果 Redis 中也没有就是真的没有 3、淘宝出的 canal 分库、分表分库：将一个数据库分成多个数据库。 分表：将一张表分成多张表。 分库当网站的访问量非常大时，我们为了提高数据的性能，我们需要将数据库根据业务逻辑拆分成多个库，然后就可以放到不同的集群上： 在分库之后要尽量避免跨库操作，所以我们在分库时，应该把需要连表操作的表放到一个库中，比如订单表和订单商品表。如果实在需要跨库联表操作时，我们就得使用程序拆分 SQL 语句分别查询。 分表我们在项目中应该避免出现 大表。 当一个表非常大的时，对这个表进行的操作都将消耗大量的时间，操作这样的表简直就是恶梦！ 什么样的表算大表呢？ 一般的标准是： 1、表中的记录数超过 2千万 2、数据文件超过 10 G 这个没有统一的标准，不同的表结构，不同的硬件对大表的定义都不同，所以要灵活定义。 为了避免出现大表的情况，我们可以使用 分表 的技术。 分表：把一张表中的数据分拆到多张表中。 分表分为横向分表 和 纵向分表 两种： 横向分表：当表中数据量比较大时，将数据保存到多个表中。 纵向分表：当表中字段比较多时，就可以将常用的字段，和不常用的字段分到多个表中。 原则：常用的字段一个表（热数据），不常用的另一个表（冷数据） 中间件在分库、分表的架构中，对于数据的操作比较复杂，比如，在添加数据时，我们要计算数据应该插入到哪个库的哪个表中，要查询数据时还要考虑跨库、跨表的查询、排序、合并等问题。如果这些工作都由我们自己编码来实现，那么难度是非常大的。这时我们可以使用一些中间件来帮助我们简化开发。 常用的中间件有： 1、MyCat 2、OneProxy 3、ProxySQL 4、Atlas [mark] (参考自我的上课讲义) 未完待续！","categories":[{"name":"Coding","slug":"Coding","permalink":"https://jiaobantang.github.io/categories/Coding/"},{"name":"Docker","slug":"Coding/Docker","permalink":"https://jiaobantang.github.io/categories/Coding/Docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://jiaobantang.github.io/tags/docker/"}]},{"title":"Docker入门并搭建PHP（LNMP）运行环境","slug":"docker-1","date":"2018-12-03T07:18:32.000Z","updated":"2020-01-03T08:54:37.344Z","comments":true,"path":"2018/12/03/docker-1/","link":"","permalink":"https://jiaobantang.github.io/2018/12/03/docker-1/","excerpt":"Docker的简单介绍1、docker是什么？docker 是一个开源的应用容器引擎，基于Go语言实现，属于操作系统层面的虚拟技术。 docker可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何安装有docker的电脑上。 容器是完全使用沙盒机制，相互之间不会有任何接口（类似 iphone 的 app），更重要的是容器性能开销较低","text":"Docker的简单介绍1、docker是什么？docker 是一个开源的应用容器引擎，基于Go语言实现，属于操作系统层面的虚拟技术。 docker可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何安装有docker的电脑上。 容器是完全使用沙盒机制，相互之间不会有任何接口（类似 iphone 的 app），更重要的是容器性能开销较低 2、docker能够做什么？docker可以解决虚拟机能够解决的问题，同时也能够解决虚拟机由于电脑资源要求过高而无法解决的问题 3、为什么使用docker1更快速的交付和部署对开发和运维员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。 例如：开发者可以使用一个标准的镜像来构建一套开发容器，开发完成之后，运维人员可以直接使用这个容器来部署代码。Docker 容器很轻很快！容器的启动时间是秒级的，大量地节约开发、测试、部署的时间。节约安装各种开发环境的软件的时间。解决开发环境和生产环境不一致的问题。 2、更轻松的迁移和扩展：Docker 容器几乎可以在任意的平台上运行，包括物理机、虚拟机、公有云、私有云、个人电脑、服务器等。 这种兼容性可以让用户把一个应用程序从一个平台直接迁移到另外一个。 3、更高的资源利用率：Docker 是容器技术，和虚拟机非常像，都可以在主机上隔离出多个独立的子系统，它们最大的区别在于虚拟机是从主机中完全隔离出一个系统来，而容器技术和主机是共享系统内核的。因为这些Docker 对系统资源的利用率很高，一台主机上可以同时运行数千个 Docker 容器。容器除了运行其中应用外，基本不消耗额外的系统资源，使得应用的性能很高，同时系统的开销尽量小。传统虚拟机方式运行 10 个不同的应用就要起 10 个虚拟机，而Docker 只需要启动 10 个隔离的应用容器即可。 总结：Docker背后的想法是创建软件程序可移植的轻量级容器，让其可以在任何安装了Docker的机器上运行，并不用关心底层操作系统，就像野心勃勃的造船者们成功创建了集装箱而不需要考虑装在哪种船舶上一样。 只有一个共同目标：简化部署流程，提高生产力！ 4、Docker快速体验-wordpress搭建WordPress是使用PHP语言开发的博客平台，用户可以在支持PHP和MySQL数据库的服务器上架设属于自己的网站。也可以把 WordPress当作一个内容管理系统（CMS）来使用。wordpress的运行环境已经全部打包好了,同时wordpress也被打包进去了，所以紧紧几个命令就可以搞定了。首先下载mysql 1docker pull mysql:5.7 *下载wordpress镜像 * 1docker pull wordpress *安装MySQL容器 * 1docker run --name mysql -e MYSQL_ROOT_PASSWORD=admin -p 3306:3306 -d mysql:5.7 安装wordpress 1docker run -itd --name wordpress -e WORDPRESS_DB_HOST=mysql -e WORDPRESS_DB_PASSWORD=admin -p 8080:80 --link mysql:mysql -d wordpress *访问wordpress * 1localhost:8080或者127.0.0.1:8080 5、docker 项目架构如果我们相对docker有个深入的理解我们必须先认识docker的项目架构 Docker使用C/S架构，通过docker客户端连接到Docker服务器上从而管理Docker服务器里面的镜像和容器，类似于git的架构。 6、Docker的基本概念镜像（images）Docker 镜像（Image）就是一个只读的模板。例如：一个镜像可以包含一个完整的操作系统环境，里面仅安装了 Apache 或用户需要的其它应用程序。镜像可以用来创建 Docker 容器，一个镜像可以创建很多容器。Docker 提供了一个很简单的机制来创建镜像或者更新现有的镜像，用户甚至可以直接从其他人那里下载一个已经做好的镜像来直接使用。 容器（Conrainer）Docker 利用容器（Container）来运行应用。容器是从镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。可以把容器看做是一个易版的 Linux 环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。 文件系统隔离技术使得Docker成为了一个非常有潜力的虚拟化技术。在容器中可以对文件进行修改、删除、创建。 仓库（Registry）仓库（Repository）是集中存放镜像文件的场所。有时候会把仓库和仓库注册服务器（Registry）混为一谈，并不严格区分。实际上，仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）。 仓库分为公开仓库（Public）和私有仓库（Private）两种形式。最大的公开仓库是 Docker Hub，存放了数量庞大的镜像供用户下载。国内的公开仓库包括 时速云 、网易云 等，可以提供大陆用户更稳定快速的访问。当然，用户也可以在本地网络内创建一个私有仓库。 当用户创建了自己的镜像之后就可以使用 push 命令将它上传到公有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上 pull 下来就可以了。Docker 仓库的概念跟 Git 类似，注册服务器可以理解为GitHub 这样的托管服务。 DockerfileDockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。一般用来定制镜像 Docker常用的指令和参数一般我们都是用指令操作来操作docker的 常用指令 指令 说明 docker images 查看已下载的镜像 docker rmi 镜像名称:标签名 删除已下载的镜像 docker search 镜像 从官方仓库（hub.docker.com）查找镜像 docker pull 镜像名称:标签名 标签名默认是 latest，代表最新版本。 docker run 创建容器 docker ps 列出运行中的容器（运行中） docker ps -a 列出未运行的容器 docker rm 容器名称 删除停止的容器 docker rm -f 容器名称 删除运行中的容器 docker start 容器名称 启动容器 docker stop 容器名称 停止容器 docker restart 容器名称 重启容器 docker exec 执行容器中的指令 ### 常用参数 下载了镜像之后，我们就可以通过镜像来创建容器，创建容器时常用的参数是： 1docker run --name 容器名称 -d -p 主机端口:容器内端口 -e 环境变量 --link 其它容器名:容器中别名 镜像名称:标签名 参数说明： –name：指定容器名称 -d：容器在后台运行 -p：绑定端口号，容器内部的端口号无法在外部访问，必须经过绑定之后才可以访问 –link：连接其它容器，当要访问其它容器中的内容时，需要先链接才可以使用 -e：设置容器中的环境变量 Docker的常用操作创建容器创建一个 MySQL 容器，密码是123456，绑定本地 33306 端口到容器中 3306 端口： 1docker run --name mysql01 -d -p 33306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7 说明：MYSQL_ROOT_PASSWORD 环境变量用来设置这个容器中 MySQL 的密码 创建之后，会启动这个容器，如果启动成功，就可以使用 docker ps 指令查看到： 启动之后，这个容器内部就运行了 MySQL 服务器，在容器内部监听的是 3306 端口，我们已经将这个端口绑定到了主机的 33306 端口上，所以我们在主机上可以使用 33306 端口连接 进入容器有时我们需要进入到一个容器内部去操作这个容器，这时我们可以使用 docker exec 指令来实现。 docker exec 指令可以执行一个运行着的容器中的命令： 1docker exec -it 容器名称 命令 我们可以通过执行 bash 指令进入容器： 1docker exec -it mysql01 bash 或者 1docker exec -it mysql01 /bin/sh -it：以实时交互的形式运行（和 -d 正好相反） 执行之后就进入到了容器中，然后我们输入的命令是在容器中执行的 执行 exit 指令可以退出容器。 链接容器Docker 推荐我们一个容器中只运行一个主要的应用程序，比如，我们要运行一个 PHP + MySQL 的程序，那么我们应该把 PHP 和 MySQL 放到两个容器中 默认情况下，容器之间是不能直接通信的，如果要通信必须在创建 PHP 容器时使用 --link 参数建立和 MySQL 容器的链接 建立连接的参数说明： 1--link 要连接的容器的名称 : 别名 在容器中可以使用别名来访问连接的容器。 比如，我们现在运行了一个叫做 mysql01 的容器，现在我们要创建一个 PHP 容器并和 MySQL 容器建立链接，指令应该是： 创建一个 PHP 容器，并且设置和 mysql01 容器建立连接，在 PHP 容器中连接的别名是 mysql 1docker run --name php01 -d --link mysql01:mysql php 创建了链接之后，就可以在容器中使用别名来通信了： 12// 连接 mysql01 容器中的 MySQL 服务器$pdo = new PDO('mysql:host=mysql:33306;dbname=xxx', 'root', '123456') 扩展：我们可以同时添加多个 –link 来同时连接多个容器，比如同时连接mysq01和redis01两个容器： 1docker run --name php01 -d --link mysql01:mysql --link redis01:redis php 挂载硬盘问题一、数据是保存在容器里的，如果容器删除了数据也就删除了。 问题二、每次要修改容器时，必须要进入到容器中去修改，比如要修改my.cnf。 为了能够保存（持久化）数据以及共享容器间的数据，Docker 提出了 Volume 的概念。 可以使用 -v 这个参数，将容器中的一个目录或者文件 和主机上的目录和文件进行绑定，绑定之后，修改主机上的这个文件就相当于修改了容器中的文件，删除容器之后，绑定的目录和文件还在主机（不会被删除）。 为了实现主机和容器之间的数据共享，我们可以在创建容器时添加 -v 参数： 1docker run ... -v 主机目录:容器中的目录 ... 示例：创建 mysql 容器并将数据目录挂载到主机： 1docker run --name mysql02 -d -v /home/home/code/docker-volume-data/testmysql:/var/lib/mysql -p 33307:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7.24 示例：启动一个 Nginx 服务器并将 nginx 的主目录搭载到主机上 1、下载 nginx 1docker pull nginx:1.14.1-alpine 2、到容器中查看网站根目录的路径 12docker run --name testnginx -d nginx:1.14.1-alpine ## 创建容器docker exec -it testnginx /bin/sh ## 进入容器 在容器中使用 vi 编辑器查看配置文件： 1vi /etc/nginx/conf.d/default.conf 查看网站根目录是 usr/share/nginx/html。 删除该容器 1docker rm -f testnginx 3、创建 nginx 容器并将 /usr/share/nginx/html 挂载到本地 1docker run --name nginx01 -d -p 30080:80 -v 本地目录:/usr/share/nginx/html nginx.1.14.1-alpine 复制文件我们可以使用 docker cp 指令向容器中复制文件，或者从容器中复制文件到主机。 1docker cp 源目录 目标目录 复制主机文件到容器1docker cp C:/my.cnf mysql01:/etc/mysql/my.cnf 从容器复制文件到主机1docker cp mysql01:/etc/mysql/my.cnf C:/my.cnf 使用 Docker 搭建 LNMP 环境平时在做开发时，为了简单、方便常用以下开发环境：1、WAMP2、Visual AMP\\NMP3、PHP 内置 WEB 服务器，如 php -S localhost:9999 -t 还有 Laravel 中的 php artisan serve --port 801 。以上这三种只适用于开发时使用，在真正的线上环境我们需要安装更加稳定并且能够支撑高并发的运行环境，目前 PHP 的生产环境最常用的就是 LNMP。 LNMP：Linux + Nginx + MySQL + PHP NginxNginx 是目前最流行的高性能、高并发的开源、免费的 WEB 服务器，俄罗斯人开发的。 Nginx 使用 Linux 中最流行的 epoll 做为事件处理机制，并且 Nginx 在运行时只消耗极少的系统资源，所以可以轻松实现上万的并发请求，Nginx 除了可以做为 WEB 服务器之外，还可以做为Email、反向代理、负载均衡、流媒体等服务器。Nginx 和其它脚本语言（如PHP）一起工作时一般使用 FastCGI 机制。 方案方案一、一个容器中同时运行 nginx php-mpm​ 好处：简单、方便​ 缺点：不利于每个软件的横向扩展方案二、把 nginx、php-fpm、MySQL 分别放到三个容器中​ 好处：有利于单独扩展每个系统​ 缺点：部署相对复杂我选择的是方案二 LNMP 模型图创建三个容器：Nginx、PHP-FPM、MySQL，它们之间的关系是：（说明：图中端口可以任意修改） 总结：Nginx 负载处理静态文件，如果用户访问的是 PHP 文件，就转发给 PHP 服务器的9000来处理，PHP服务器处理完之后，把结果返回给 nginx,然后nginx再返回给前端。 1、下载镜像 下载 nginx 镜像（alpine版的更小） 1docker pull nginx:1.14-1-alpine 下载 MySQL 镜像 1docker pull mysql:5.7 下载 PHP-FPM 镜像 1docker pull php:7.2-fpm-alpine 2、创建容器 我们创建三个容器 Nginx、PHP-FPM、MySQL，这里需要注意的是它们创建的顺序： MySQL =&gt; PHP-FPM =&gt; Nginx 创建 MySQL 容器 1docker run --name mysql01 -d -p 33306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7 创建 php 容器 1docker run --name phpfpm7.2 -d --link mysql01:mysql php:7.2-fpm-alpine 创建 nginx 容器 1docker run --name nginx -d -p 8988:80 --link phpfpm7.2:php nginx:1.14.1-alpine 3、配置 NginxNginx 只能对静态文件（html，css，js，图片等）进行处理，无法处理动态文件（php、python等），我们需要配置 nginx 将动态脚本转发给 PHP 服务器。a. 进入 nginx 容器 1docker exec -it nginx /bin/sh b、查找配置文件位置 1find / -name nginx.conf c、修改 Nginx 的配置文件/etc/nginx/conf.d/default.conf 12345678910111213141516server &#123; ... location / &#123; root /usr/share/nginx/html; # 网站根目录 index index.html index.htm; &#125; ... location ~ \\.php$ &#123; fastcgi_pass php:9000; # 转发到 PHP 服务器的地址,PHP是容器的别名 fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /php$fastcgi_script_name; # 转发的文件名 include fastcgi_params; &#125; ...&#125; 说明：$fastcgi_script_name ：代表当前访问的文件名，比如，如果访问的是 localhost/1.php ，那么这一项的值就是 1.phpd、退出 nginx 容器并重新启该容器因为我们修改了 nginx 的配置文件，所以我们需要重启服务器 1docker restart nginx e、进入 phpfpm 容器创建 /php 目录在 nginx 中我们配置了，当遇到 PHP 脚本时，就转发 /php$fastcgi_script_name; 这个路径到 php 容器，所以PHP会到它的 /php 目录下去查找，所以我们需要进入 PHP 创建中并创建这个目录。进入PHP容器 1docker exec -it phpfpm7.2 /bin/sh 进入容器之后，创建目录 1mkdir /php 然后我们就可以在 /php 目录中创建 php 脚本了，这些脚本就可以通过浏览器运行访问了。Nginx 运行PHP的流程：a、nginx 判断访问的文件以 .php 结尾b、nginx 将 /php/1.php 这个路径传给 PHP 的9000端口c、PHP接收到nginx传过来的路径，就在本机中读取这个文件并运行d、PHP将运行结果返回给 nginxe、NGINX将结果返回给用户 两个问题lnmp环境搭建好了，但是还有些问题需要考虑1、为PHP容器中安装扩展我们使用的是 PHP 默认的镜像，这个镜像中缺少很多必要的 PHP 扩展，比如 gd、redis、pdo_mysql 等，这些扩展都需要单独安装。不过官方提供了安装扩展的两种方法：​ 核心扩展（pdo_mysql,gd等） 使用 docker-php-ext-install如安装 gd 库：(先进入PHP容器，然后执行以下命令) 1docker-php-ext-install gd ​ 其它扩展（redis、yaf、swoole等）使用 pecl如安装 redis：(先进入PHP容器，然后执行以下命令) 12pecl install redisdocker-php-ext-enable redis 2、把两个容器代码的目录都绑定到一个目录中现在我们需要把静态页保存到 nginx 容器中，然后把 php 脚本写到 php 容器中，这样在放代码时比较麻烦，所以我们可以将两个服务器的代码目录都绑定到本机，这样直接在本机就可以编写代码了。a、在本机创建一代码目录b、删除nginx容器重新创建一个新的容器 1docker run --name nginx -d -p 8888:80 -v 本地目录:/usr/share/nginx/html --link phpfpm7.2:php nginx:1.14.1-alpine 通过 -v 我们就把 nginx 中网站根目录绑定球果一地的目录中了。创建 nginx 容器之后，重新向前面一样修改一下 /etc/nginx/conf.d/default.conf 配置文件，然后重新启动即可。c、删除PHP容器然后重新创建一个新的容器 1docker run --name phpfpm7.2 -d -v 本地目录:/php --link mysql01:mysql php:7.2-fpm-alpine","categories":[{"name":"Coding","slug":"Coding","permalink":"https://jiaobantang.github.io/categories/Coding/"},{"name":"Docker","slug":"Coding/Docker","permalink":"https://jiaobantang.github.io/categories/Coding/Docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://jiaobantang.github.io/tags/docker/"},{"name":"php","slug":"php","permalink":"https://jiaobantang.github.io/tags/php/"}]},{"title":"PHP版本的（snowflake）","slug":"snowflake","date":"2018-11-26T06:50:20.000Z","updated":"2019-03-05T13:06:49.251Z","comments":true,"path":"2018/11/26/snowflake/","link":"","permalink":"https://jiaobantang.github.io/2018/11/26/snowflake/","excerpt":"snowflake算法好像是订单号的妈妈","text":"snowflake算法好像是订单号的妈妈 生成订单号在下订单时，我们需要为订单生成一个 唯一 的订单号，为了能够生成一个在高并发、集群环境下依然唯一的订单号，我们可以使用 twitter 提供的 snowflake 算法。 snowflakesnowflake 算法生成的订单号是由 64位（8个字节）二进制数来保存的，它的每一位的含义如下： PHP 版本的 snowflake由于 PHP 语言的特点，PHP中的数据用完就会销毁，下次再执行时又是全新的数据，这就导致在 PHP 中无效保存 上一次的数据 以及 持久存在的数字序列，为了解决这两个问题，我们可以使用 redis 来保存需要持久存在的数据。Snowflake 中有两个数据需要保存到 Redis ：上次生成的时间戳 和 序列ID。所以修改之后的PHP版本的 Snowflake 为(以laravel框架实例)： 1、安装 redis 扩展 1composer require predis/predis 2、在自定义php文件里添加 snowflake 类laravel自定义全局函数看这里这里在 app/helpers.php 文件中添加 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118&lt;?phpuse Illuminate\\Support\\Facades\\Redis;...// 生成唯一订单编号function getOrderSn()&#123; $sf = new SnowFlake(0, 0); return $sf-&gt;generateID();&#125;class SnowFlake&#123; /** * Offset from Unix Epoch * Unix Epoch : January 1 1970 00:00:00 GMT * Epoch Offset : January 1 2000 00:00:00 GMT */ const EPOCH_OFFSET = 1483200000000; const SIGN_BITS = 1; const TIMESTAMP_BITS = 41; const DATACENTER_BITS = 5; const MACHINE_ID_BITS = 5; const SEQUENCE_BITS = 12; /** * @var mixed */ protected $datacenter_id; /** * @var mixed */ protected $machine_id; /** * @var null|int */ // protected $lastTimestamp = null; 需要保存到 Redis /** * @var int */ // protected $sequence = 1; 需要保存到 Redis protected $signLeftShift = self::TIMESTAMP_BITS + self::DATACENTER_BITS + self::MACHINE_ID_BITS + self::SEQUENCE_BITS; protected $timestampLeftShift = self::DATACENTER_BITS + self::MACHINE_ID_BITS + self::SEQUENCE_BITS; protected $dataCenterLeftShift = self::MACHINE_ID_BITS + self::SEQUENCE_BITS; protected $machineLeftShift = self::SEQUENCE_BITS; protected $maxSequenceId = -1 ^ (-1 &lt;&lt; self::SEQUENCE_BITS); protected $maxMachineId = -1 ^ (-1 &lt;&lt; self::MACHINE_ID_BITS); protected $maxDataCenterId = -1 ^ (-1 &lt;&lt; self::DATACENTER_BITS); /** * Constructor to set required paremeters * * @param mixed $dataCenter_id Unique ID for datacenter (if multiple locations are used) * @param mixed $machine_id Unique ID for machine (if multiple machines are used) * @throws \\Exception */ public function __construct($dataCenter_id, $machine_id) &#123; if ($dataCenter_id &gt; $this-&gt;maxDataCenterId) &#123; throw new \\Exception('dataCenter id should between 0 and ' . $this-&gt;maxDataCenterId); &#125; if ($machine_id &gt; $this-&gt;maxMachineId) &#123; throw new \\Exception('machine id should between 0 and ' . $this-&gt;maxMachineId); &#125; $this-&gt;datacenter_id = $dataCenter_id; $this-&gt;machine_id = $machine_id; &#125; /** * Generate an unique ID based on SnowFlake * @return string * @throws \\Exception */ public function generateID() &#123; $sign = 0; // default 0 $timestamp = $this-&gt;getUnixTimestamp(); $lastTimeStamp = Redis::get('shop:order:lastTimeStamp'); if ($timestamp &lt; $lastTimeStamp) &#123; throw new \\Exception('\"Clock moved backwards!'); &#125; if ($timestamp == $lastTimeStamp) &#123; //与上次时间戳相等，需要生成序列号 $sequence = Redis::incr('shop:order:sequence'); if ($sequence == $this-&gt;maxSequenceId) &#123; //如果序列号超限，则需要重新获取时间 $timestamp = $this-&gt;getUnixTimestamp(); while ($timestamp &lt;= $lastTimeStamp) &#123; $timestamp = $this-&gt;getUnixTimestamp(); &#125; Redis::set('shop:order:sequence', 1); $sequence = 1; &#125; &#125; else &#123; Redis::set('shop:order:sequence', 1); $sequence = 1; &#125; Redis::set('shop:order:lastTimeStamp', $timestamp); $time = (int)($timestamp - self::EPOCH_OFFSET); $id = ($sign &lt;&lt; $this-&gt;signLeftShift) | ($time &lt;&lt; $this-&gt;timestampLeftShift) | ($this-&gt;datacenter_id &lt;&lt; $this-&gt;dataCenterLeftShift) | ($this-&gt;machine_id &lt;&lt; $this-&gt;machineLeftShift) | $sequence; return (string)$id; &#125; /** * Get UNIX timestamp in microseconds * * @return int Timestamp in microseconds */ private function getUnixTimestamp() &#123; return floor(microtime(true) * 1000); &#125;&#125; 添加之后就可以在项目中使用 getOrderSn 函数来生成订单号了： 123 Route::get('testSN', function()&#123; return getOrderSn();&#125;); 参考自我的课程讲义","categories":[{"name":"PHP","slug":"PHP","permalink":"https://jiaobantang.github.io/categories/PHP/"}],"tags":[{"name":"snowflake","slug":"snowflake","permalink":"https://jiaobantang.github.io/tags/snowflake/"}]},{"title":"接口开发之后端","slug":"rest","date":"2018-11-24T00:52:14.000Z","updated":"2020-01-03T08:59:14.259Z","comments":true,"path":"2018/11/24/rest/","link":"","permalink":"https://jiaobantang.github.io/2018/11/24/rest/","excerpt":"我也挺喜欢前后端分离来开发项目的，虽然都得自己干。","text":"我也挺喜欢前后端分离来开发项目的，虽然都得自己干。 前、后端分离随着前端设备（智能手机、IPAD、平板、笔记本、摄像头、智能家具等）的及物联网的发展，前端的形式变得更加多样化： 在这种时代的大背景下，传统的 在前端代码中嵌入后端代码的混合式开发 已经无法满足目前的情况了。 前端技术慢慢从后端开发中分离了出来，前端只关注前端页在，后端只负责数据的处理，后端负责提供数据接口与前端进行通信，通信时一般使用 json/xml 格式。 既然前、后端通过接口进行沟通，那么我们就要为接口定义一个规范，如果所有的接口都满足同样的规范，就可以降低沟通和开发的成本。 REST 规范 RESTful 是一种软件设计风格，由 Roy Fielding 在他的 论文 中提出，全称为 Representational State Transfer，直译为表现层状态转移。 RESTful 风格的接口，目前来看，实现的最好的就是 Github API，经常被效仿。接下来我们通过分析 Github API 来引出我们的 API 设计原则。 使用 HTTPSHTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的 HTTP 通道，简单讲是 HTTP 的安全版。 HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 HTTPS 为接口的安全提供了保障，可以有效防止通信被窃听和篡改。 域名应当尽可能的将 API 与其主域名区分开，可以使用专用的域名，访问我们的 API，例如： 1https://api.xxx.com 或者可以放在主域名下，例如： 1https://www.xxx.com/api 版本控制随着业务的发展，需求的不断变化，API 的迭代是必然的，很可能当前版本正在使用，而我们就得开发甚至上线一个不兼容的新版本，为了让旧用户可以正常使用，为了保证开发的顺利进行，我们需要控制好 API 的版本。 通常情况下，有两种做法： 将版本号直接加入 URL 中 12https://api.xxx.com/v1https://api.xxx.com/v2 接口命名规则一、使用 HTTP 动词代表操作的类型。 动词 描述 GET 获取资源，单个或多个 POST 创建资源 PUT 更新资源，客户端提供完整的资源数据 PATCH 更新资源，客户端提供部分的资源数据 DELETE 删除资源 GitHub 网站的一些例子： 1234567GET /issues 列出所有的 issueGET /repos/:owner/:repo 列出某个项目的 信息GET /repos/:owner/:repo/issues/:number 获取某个项目的某个 issuePOST /repos/:owner/:repo/issues 为某个项目创建 issuePATCH /repos/:owner/:repo/issues/:number 修改某个 issuePUT /repos/:owner/:repo/issues/:number/lock 锁住某个 issueDELETE /repos/:owner/:repo/issues/:number/lock 接收某个 issue 说明：冒号（：xx)）开始的代表变量，例如 /repos/fortheday001/jxshop 规则二、接口地址的命名应该是名词（一般是复数形式） 错误的例子： 1234POST https://api.xxx.com/createTopicGET https://api.xxx.com/topic/show/1POST https://api.xxx.com/topics/1/comments/createPOST https://api.xxx.com/topics/1/comments/100/delete 正确的例子（名词）： 1234POST https://api.xxx.com/topicsGET https://api.xxx.com/topics/1POST https://api.xxx.com/topics/1/commentsDELETE https://api.xxx.com/topics/1/comments/100 资源过滤当我们需要搜索、排序、分页等过滤数据时我们需要在 URL 传合适的参数： 123?state=closed: 不同状态的资源?page=2&amp;per_page=100：访问第几页数据，每页多少条。?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。 比如获取10条用户的请求地址为： 1GET /users?per_page=10 正确使用状态码接口在返回数据时应该正确的返回 HTTP 对应的状态码，常用的状态码如下： 常用状态码： 1234567$_http_code = [ 200 =&gt; \"OK\", // 成功 400 =&gt; \"Bad Request\", // 请求数据有问题 401 =&gt; \"Unauthorized\", // 未登录 403 =&gt; \"Forbidden\", // 登录但没有权限 404 =&gt; \"Not Found\", // 请求数据没找到]; 数据响应格式接口应该返回 JSON 或者 XML 格式的数据。 返回的数据的结构应该有一个固定的结构，这个结构可以自己设计，比如： 12345&apos;message&apos; =&gt; &apos;:message&apos;, // 错误的具体描述&apos;errors&apos; =&gt; &apos;:errors&apos;, // 参数的具体错误描述，422 等状态提供&apos;code&apos; =&gt; &apos;:code&apos;, // 自定义的异常码&apos;status_code&apos; =&gt; &apos;:status_code&apos;, // http状态码&apos;debug&apos; =&gt; &apos;:debug&apos;, // debug 信息，非生产环境提供 例如： 123456789&#123; \"message\": \"422 Unprocessable Entity\", \"errors\": &#123; \"name\": [ \"姓名 必须为字符串。\" ] &#125;, \"status_code\": 422&#125; 1234&#123; \"message\": \"您无权访问该订单\", \"status_code\": 403&#125; 频繁限制为了防止服务器被攻击，减少服务器压力，需要对接口进行合适的限流控制，需要在响应头信息中加入合适的信息，告知客户端当前的限流情况 X-RateLimit-Limit :100 最大访问次数 X-RateLimit-Remaining :93 剩余的访问次数 X-RateLimit-Reset :1513784506 到该时间点，访问次数会重置为 X-RateLimit-Limit 示例： 1234567curl -i https://api.github.com/users/octocatHTTP/1.1 200 OKDate: Mon, 01 Jul 2013 17:27:06 GMTStatus: 200 OKX-RateLimit-Limit: 60X-RateLimit-Remaining: 56X-RateLimit-Reset: 1372700873 超过限流次数后，需要返回 429 Too Many Requests 错误。 编写文档为了方便用户使用，我们需要提供清晰的文档，尽可能包括以下几点 包括每个接口的请求参数，每个参数的类型限制，是否必填，可选的值等。 响应结果的例子说明，包括响应结果中，每个参数的释义。 对于某一类接口，需要有尽量详细的文字说明，比如针对一些特定场景，接口应该如何调用。 Postmanpostman 是一个接口访问软件，非常适合服务器端程序员用来测试接口、发布接口文档等。 集合管理我们可以在左侧创建接口集合，将项目中所有的接口都统一分类管理起来： 环境变量我们可以在软件中管理环境变量，环境变量可以让我们把系统的IP地址、JWT字符串等常用的内容定义到变量中保存，然后通过变量来使用这个数据，就不用每次都填写了： 添加环境变量： 添加之后，就可以通过 来使用了： 保存示例数据当我们使用 postman 请求接口之后，会为我们美化服务器返回的数据： 返回数据之后，我们可以点击 Save Response 按钮保存返回的数据，保存的目的是在制作接口文档时，这些数据可以做为示例数据，保存时可以设置一个名字： 生成接口文档postman 还有一个好用的功能就是可以帮助我们生成 接口文档。 当我们编写好接口以及保存好接口返回的数据示例之后，我们就可以使用它来生成 接口文档： 点击 Publish Docs 生成接口文档时，先选择我们要使用的环境变量： 选择完之后就可以发布了，发布之后，我们就得到发布之后的浏览地址： 把这个接口地址发给前端程序员就可以了： 接口文档地址：https://documenter.getpostman.com/view/3908128/RzZDjxgP Laravel定义路由在做接口开发时，所有的接口都定义在 routes/api.php 文件中。 定义在 routes/api.php 文件中的路由有几下几个特点： 1、接口地址中必须加上 api 前缀，比如：http://127.0.0.1:8000/api/goods 2、没有 csrf 、session、cookie等传统网站开发中的常用功能（这些功能使用 jwt(json web token)（令牌）替代） 3、所有接口都会有频率限制（每分钟60次）（通过 Laravel 中自带的 throttle 中间件实现） 频率限制routes/api.php 文件中定义的路由都会默认被应用 throttle 中间件，同一个IP1分钟内最多访问一个接口60次。 如果要为不同的接口设置不同的频率，可以在 routes/api.php 文件中定义路由时，先定义路由组，然后为这个路由组设置频率，所有这个组中的路由都会被应用同样的频率限制： 123456789101112// 1分钟最多5次Route::group(['prefix'=&gt;'api','middleware'=&gt;'throttle:5'],function()&#123; Route::get('users',function()&#123; return \\App\\User::all(); &#125;);&#125;);// 10分钟最多5次Route::group(['prefix'=&gt;'api','middleware'=&gt;'throttle:5,10'],function()&#123; Route::get('users',function()&#123; return \\App\\User::all(); &#125;);&#125;); AJAX跨域在前、后端分离开发时，前端都是使用 ajax 与服务器端进行通信的，但是 ajax 有一个限制：不能跨域名访问服务器接口。 在实现工作中，前端和后端经常是部署在不同的服务器上，也就都拥有不同的域名，这时前端发送 AJAX 就会报错，比如：前端在 127.0.0.1:8000 这个域名下，而后端在 127.0.0.1:8080 这个端口下时： 解决办法： 目前常用的解决办法有 jsonp 和 cors。 JSONP：只支持 GET 请求的跨域。 CORS：(跨站资源共享)，实现原理是在服务器端设置几个 http 协议头即可，缺点是有些老旧的浏览器不支持。 Laravel 中使用 CORS： 如果每次发请求时都手动设置协议头太麻烦了，所以可以使用 Laravel 中间件来实现。 Laravel 的中间件会在接收和发送请求时自动被调用，这样就可以只编写一次代码就可以在每次请求时自动设置协议头了。 1、创建中间件 1php artisan make:middleware CorsMiddleware 2、编写代码 app\\Http\\Middleware\\CorsMiddleware.php 123456789101112131415161718192021public function handle($request, Closure $next)&#123; $response = $next($request); $origin = $request-&gt;server('HTTP_ORIGIN') ? $request-&gt;server('HTTP_ORIGIN') : ''; // 允许访问的域名列表 $allow_origin = [ 'http://localhost:8080', ]; // 通过 $response-&gt;header 设置协议头 // (扩展：如果想要允许所有域名跨域访问，就可以去掉if判断，然后 // 直接设置 Access-Control-Allow-Origin : *) if (in_array($origin, $allow_origin)) &#123; // 如果要允许所有域名跨域访问，设置把这一项设置为 * $response-&gt;header('Access-Control-Allow-Origin', $origin); $response-&gt;header('Access-Control-Allow-Methods', 'GET, POST, PATCH, PUT, DELETE, OPTIONS'); $response-&gt;header('Access-Control-Allow-Headers', 'Origin, Content-Type, Cookie, X-CSRF-TOKEN, Accept, Authorization, X-XSRF-TOKEN'); $response-&gt;header('Access-Control-Expose-Headers', 'Authorization, authenticated'); $response-&gt;header('Access-Control-Allow-Credentials', 'true'); &#125; return $response;&#125; 3、注册中间件 app\\Http\\Kernel.php 文件中注册全局中间件。 注册到 $middleware 数组中的中间件会在所有请求时会自动调用。 12345678protected $middleware = [ \\App\\Http\\Middleware\\CheckForMaintenanceMode::class, \\Illuminate\\Foundation\\Http\\Middleware\\ValidatePostSize::class, \\App\\Http\\Middleware\\TrimStrings::class, \\Illuminate\\Foundation\\Http\\Middleware\\ConvertEmptyStringsToNull::class, \\App\\Http\\Middleware\\TrustProxies::class, \\App\\Http\\Middleware\\CorsMiddleware::class]; 发送 HTTP 状态码在 Laravel 框架中可以直接使用 response 方法向前端发送数据和状态码信息。 1return response('无权访问！'， 403); 这时框架会在发送数据时设置一个 403 的协议头信息，当浏览器收到非 2xx 开头的状态码时会显示显示错误信息： 当我们使用 axios 请求这个地址时，如果服务器返回的是非 2xx 开头的状态码，那么就会认为发生了错误，错误信息需要在 catch 中获取： 1234567891011121314151617181920axios.get('http://127.0.0.1:8000/api/test') .then((res)=&gt;&#123; // 服务器返回了 2xx 状态码(代码成功时执行) console.log( res.data ) &#125;) .catch((err)=&gt;&#123; if (err.response) &#123; // 服务器返回了一个非 2xx 的状态码时 console.log(err.response.data); console.log(err.response.status); console.log(err.response.headers); &#125; else if (err.request) &#123; // 发送请求时出错(没有发送成功) console.log(err.request); &#125; else &#123; // 设置 axios 时出错(没有发送成功) console.log('Error', err.message); &#125; console.log(err.config); &#125; 发送自定义状态码上面的方式是在 HTTP 协议头中发送状态码信息，这种方式的缺点的是：如果不是 2xx 的状态码，浏览器就会显示错误 这样的用户体验不太好。 我们可以在程序中无论正确与否都发送 200 状态码（成功），然后把错误的状态码信息放到我们自定义的数据中返回给前端，然后前端通过我们定义的状态码来判断对错，这样浏览器就不会显示错误信息了： 比如：我们可以在项目中定义两个函数，成功时调用 ok 向前端发数据 ，调用时使用 error 向后端发消息： 1234567891011121314151617181920212223function ok($data)&#123; return [ 'status_code' =&gt; 200, 'message'=&gt;'ok', 'data' =&gt; $data ];&#125;function error($error, $code)&#123; static $_http_code = [ 400 =&gt; \"Bad Request\", // 请求数据有问题 401 =&gt; \"Unauthorized\", // 未登录 403 =&gt; \"Forbidden\", // 登录但没有权限 404 =&gt; \"Not Found\", // 请求数据没找到 422 =&gt; \"Unprocessable Entity\", // 无法处理输入的数据 ]; return [ 'status_code' =&gt; $code, 'message' =&gt; $_http_code[$code], 'errors' =&gt; $error ];&#125; 然后在程序中我们可以这样显示数据： 12345678910111213141516171819class TestController extends Controller&#123; public function test(Request $req) &#123; $validator = Validator::make($req-&gt;all(), [ 'title' =&gt; 'required|unique:posts|max:255', 'body' =&gt; 'required', ]); if ($validator-&gt;fails()) &#123; return error($validator-&gt;errors(), 422); &#125; return ok([ 'name' =&gt; 'tom', 'age' =&gt; 20, ]); &#125;&#125; 这时前端收到的消息时，同样返回了 422 错误的状态码，只不过这次不是在 http 协议头中返回的，是在我们正常的数据中返回的，这样浏览器就不会显示错误信息了： 在 Laravel 框架中添加自定义函数有时我们为了让 Laravel 框架更加的好用，我们会向框架中添加一些自定义的函数，那么这些自定义的函数应该放在哪里？其实，我们可以这样做： 1、创建 app\\helpers.php 文件保存我们自定义的函数 app\\helpers.php 12345678910111213141516171819202122232425&lt;?phpfunction ok($data)&#123; return [ 'status_code' =&gt; 200, 'message'=&gt;'ok', 'data' =&gt; $data ];&#125;function error($error, $code)&#123; static $_http_code = [ 400 =&gt; \"Bad Request\", // 请求数据有问题 401 =&gt; \"Unauthorized\", // 未登录 403 =&gt; \"Forbidden\", // 登录但没有权限 404 =&gt; \"Not Found\", // 请求数据没找到 422 =&gt; \"Unprocessable Entity\", // 无法处理输入的数据 500 =&gt; \"Internal Server Error\", // 服务器内部错误 ]; return [ 'status_code' =&gt; $code, 'message' =&gt; $_http_code[$code], 'errors' =&gt; $error ];&#125; 2、修改 composer.json 添加自动加载项 composer.json 123456\"autoload\": &#123; ... \"files\": [ \"app/helpers.php\" ]&#125;, 3、命令行中执行加载指令 1composer dump-auto 4、重新启动 Laravel 框架然后就可以在项目中直接使用 app\\helpers.php 文件中定义的函数了。 表单验证因为 Laravel 框架中的表单验证默认的行为是 验证失败就跳转回上一个页面 ，而在做接口开发时我们需要返回 JSON 数据而不是跳转，这时我们有多种解决办法，比如：我们可以采用 手动验证 的方式来验证数据，然后自己来控制在验证失败时返回 JSON 数据： 123456789101112131415// 自己创建验证器$validator = Validator::make($req-&gt;all(), [ 'name' =&gt; 'required', 'tel' =&gt; 'required|regex:/^1[34578][0-9]&#123;9&#125;$/', 'province' =&gt; 'required', 'city' =&gt; 'required', 'area' =&gt; 'required', 'address' =&gt; 'required', 'is_default' =&gt; 'required', ]);// 如果验证失败返回 json 数据if ($validator-&gt;fails()) &#123; return error($validator-&gt;errors(), 422);&#125; JWT在 Laravel 框架中我们可以使用 php-jwt 这个扩展包来生成、验证、解析令牌。 生成令牌1、安装扩展包 1composer require firebase/php-jwt 2、.env 中定义加密密钥 .env 12JWT_KEN=fdsa32@#RFSDafpeq3r2fews8d783f;fa/fd293fJWT_EXPIRE=7200 3、生成令牌 12345678910111213141516use Firebase\\JWT\\JWT;... // 读取密钥$key = env('JWT_KEY');// 当前时间戳$now = time();// 加密数据$data = array( \"iat\" =&gt; $now, // 当前时间 \"exp\" =&gt; $now + env('JWT_EXPIRE'), // 过期时间 \"id\" =&gt; 1, // 用户ID // 其它需要保存的数据 ...);// 生成 JWT$jwt = JWT::encode($data, $key); 令牌验证在 Laravel 框架中我们可以使用中间件来验证、解析令牌，然后将解析之后的数据保存到 $request-&gt;jwt 属性中，然后在项目中就可以使用 $request-&gt;jwt 来获取 JWT 中的数据了。 1、创建中间件 app\\Http\\Middleware\\Jwt.php 123456789101112131415161718192021222324252627282930313233&lt;?phpnamespace App\\Http\\Middleware;use Closure;use \\Firebase\\JWT\\JWT as JWTCHECK;class Jwt&#123; /** * Handle an incoming request. * * @param \\Illuminate\\Http\\Request $request * @param \\Closure $next * @return mixed */ public function handle($request, Closure $next) &#123; $jwt = substr($request-&gt;server('HTTP_AUTHORIZATION'), 7); try &#123; $request-&gt;jwt = JWTCHECK::decode($jwt, env('JWT_KEY'), array('HS256')); return $next($request); &#125; catch(\\Exception $e) &#123; return response([ 'code'=&gt;'403', 'message'=&gt;'HTTP/1.1 403 Forbidden' ]); &#125; &#125;&#125; 2、注册中间件 app\\Http\\Kernel.php 123456789101112protected $routeMiddleware = [ 'auth' =&gt; \\App\\Http\\Middleware\\Authenticate::class, 'auth.basic' =&gt; \\Illuminate\\Auth\\Middleware\\AuthenticateWithBasicAuth::class, 'bindings' =&gt; \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class, 'cache.headers' =&gt; \\Illuminate\\Http\\Middleware\\SetCacheHeaders::class, 'can' =&gt; \\Illuminate\\Auth\\Middleware\\Authorize::class, 'guest' =&gt; \\App\\Http\\Middleware\\RedirectIfAuthenticated::class, 'signed' =&gt; \\Illuminate\\Routing\\Middleware\\ValidateSignature::class, 'throttle' =&gt; \\Illuminate\\Routing\\Middleware\\ThrottleRequests::class, 'verified' =&gt; \\Illuminate\\Auth\\Middleware\\EnsureEmailIsVerified::class, 'jwt' =&gt; \\App\\Http\\Middleware\\Jwt::class,]; 3、注册路由时使用中间件 routers/api.php 123456Route::post('/login', 'MemberController@login');// 应用 jwt 中间件的路由Route::middleware(['jwt'])-&gt;group(function () &#123; Route::get('/orders', 'OrderController@index');&#125;); 接口实现接下来我们学习一下如何使用 Laravel 框架实现接口的开发。 配置首先我们需要修改 .env 文件配置上数据库的账号： 123456DB_CONNECTION=mysqlDB_HOST=127.0.0.1DB_PORT=3306DB_DATABASE=jxshopDB_USERNAME=rootDB_PASSWORD=123456 配置好之后注意：需要重新启动服务。 注册接口1、首先我们在 postman 软件中定义接口的名称、地址、参数等信息： 说明： 编写接口是先创建集合，然后再创建二级目录来管理接口（接口多时好找） 接口是 post 时需要在 body 中设置需要提交的数据，一般使用 x-www-form-urlencoded 方式提交数据 通过环境变量来管理常用的数据，比如使用 host 变量保存接口地址 2、创建环境变量 在使用 postman 测试接口时，有些数据使用的频率比较高，比如：服务器地址、令牌等，这时我们就可以定义环境变量来保存这些数据，方便修改和维护。 打开环境变量管理面板： 添加一套环境变量： 输入环境变量的名字以及定义的变量和值： 创建之后选择使用环境变量： 接口写好之后就可以在 Laravel 中编写代码实现接口了。 3、配置路由 routes/api.php 1Route::post('members', 'MemberController@insert'); 4、创建模型 使用 artisan 指令创建模型并保存到 Models 目录中： 1php artisan make:model Models/Member 模型中配置基本信息： app\\Models/Member.php 1234567891011121314151617&lt;?phpnamespace App\\Models;use Illuminate\\Database\\Eloquent\\Model;class Member extends Model&#123; // 对应的表单 protected $table = 'members'; // 表中是否有两个时间字段（created_at和updated_at) public $timestamps = true; // 设置允许填充的字段 protected $fillable = ['username','password']; // 需要隐藏的字段（不会发给前端的字段） protected $hidden = ['password','updated_at','created_at'];&#125; 5、创建控制器 1php artisan make:controller MemberController app\\Controller\\MemberController.php 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?phpnamespace App\\Http\\Controllers;use Illuminate\\Http\\Request;use Validator;use App\\Models\\Member;class MemberController extends Controller&#123; public function insert(Request $req) &#123; // 生成验证器对象 // 参数一、表单中的数据 // 参数二、验证规则 $validator = Validator::make($req-&gt;all(), [ 'username'=&gt;'required|min:6|max:18|unique:members', 'password'=&gt;'required|min:6|max:18|confirmed', ]); // 如果失败 if($validator-&gt;fails()) &#123; // 获取错误信息 $errors = $validator-&gt;errors(); // 返回 JSON 对象以及 422 的状态码 return error($errors, 422); &#125; // 插入数据库 // 返回值：插入成功之后那条记录的对象 $member = Member::create([ 'username' =&gt; $req-&gt;username, 'password' =&gt; bcrypt($req-&gt;password), ]); return ok($member); &#125;&#125; 6、在 postman 中测试接口 保存返回的结果（失败、成功的结果都保存一份）： 7、发布文档 登录接口1、postman 中定义接口地址、参数等 2、定义路由 routes/api.php 1Route::post('authorizations', 'MemberController@login'); 3、控制器中添加登录方法 app\\Http\\Controllers\\MemberController.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public function login(Request $req)&#123; $validator = Validator::make($req-&gt;all(), [ 'username'=&gt;'required|min:6|max:18', 'password'=&gt;'required|min:6|max:18', ]); if($validator-&gt;fails()) &#123; // 获取错误信息 $errors = $validator-&gt;errors(); // 返回 JSON 对象以及 422 的状态码 return error($errors, 422); &#125; // 根据用户名查询账号是否存在 （只查询一条用 first 方法） $member = Member::select('id','password')-&gt;where('username',$req-&gt;username)-&gt;first(); if($member) &#123; // 判断密码 if(Hash::check($req-&gt;password, $member-&gt;password)) &#123; // 把用户的信息保存到令牌（JWT）中，然后把令牌发给前端 $now = time(); // 读取密钥 $key = env('JWT_KEY'); // 过期时间 $expire = $now + env('JWT_EXPIRE'); // 定义令牌中的数据 $data = [ 'iat' =&gt; $now, // 当前时间 'exp' =&gt; $expire, // 过期时间 'id' =&gt; $member-&gt;id, ]; // 生成令牌 $jwt = JWT::encode($data, $key); // 发给前端 return ok([ 'ACCESS_TOKEN' =&gt; $jwt, ]); &#125; else &#123; return error('密码不正确！', 400); &#125; &#125; else &#123; return error('用户名不存在！', 404); &#125;&#125; 4、下载 JWT 的包 登录时需要 JWT 令牌机制，所以需要先安装一个解析 JWT 的包： 1composer require firebase/php-jwt 5、配置 JWT .env 文件中定义 jwt 的密钥和过期时间 12JWT_KEN=fdsa32@#RFSDafpeq3r2fews8d783f;fa/fd293fJWT_EXPIRE=7200 6、保存示例结果 在 Postman 中把几种不同情况的返回结果都保存起来： 登录成功时返回令牌： 令牌的验证前端在登录成功之后，会得到令牌，然后需要把得到的令牌保存到本地，之后在请求需要验证的接口时（比如下单）需要把这个令牌在 HTTP 协议头中发送到服务器端，以进行令牌验证。 服务器端验证我们可以使用 Laravel 框架的中间件来实现令牌的验证。 1、创建中间件 1php artisan make:middleware Jwt 并编写中间件代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?phpnamespace App\\Http\\Middleware;use Closure;use \\Firebase\\JWT\\JWT as JWTCHECK;class Jwt&#123; /** * Handle an incoming request. * * @param \\Illuminate\\Http\\Request $request * @param \\Closure $next * @return mixed */ public function handle($request, Closure $next) &#123; /* 说明：客户端在提交令牌时，是把令牌放到 http 协议头中（不是表单中！！） 并且 JWT 规定前7个字符必须是 bearer （后面这里有个空格） HTTP_AUTHORIZATION: bearer fdkl;ajsf;dsajlfjl;jxxxxx 所以我们在获取令牌时，要从 $_SERVER 中获取，不是 $_POST 在 Laravel 中要获取 $_SERVER 使用 $request-&gt;server 函数 */ // 从协议头是取出令牌 $jwt = substr($request-&gt;server('HTTP_AUTHORIZATION'), 7); try &#123; // 解析 token $jwt = JWTCHECK::decode($jwt, env('JWT_KEY'), array('HS256')); // 把解析出来的数据保存到 Request 对象中的 jwt 属性上，将来在控制器中就可能 $req-&gt;jwt 这样来获取了 $request-&gt;jwt = $jwt; // 继续执行下一个中间件 return $next($request); &#125; catch(\\Exception $e) &#123; // 返回错误信息 return response([ 'code'=&gt;'403', 'message'=&gt;'HTTP/1.1 403 Forbidden' ]); &#125; &#125;&#125; 2、注册中间件到路由中间件组中 app\\Http\\Kernel.php 123456789101112protected $routeMiddleware = [ 'auth' =&gt; \\App\\Http\\Middleware\\Authenticate::class, 'auth.basic' =&gt; \\Illuminate\\Auth\\Middleware\\AuthenticateWithBasicAuth::class, 'bindings' =&gt; \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class, 'cache.headers' =&gt; \\Illuminate\\Http\\Middleware\\SetCacheHeaders::class, 'can' =&gt; \\Illuminate\\Auth\\Middleware\\Authorize::class, 'guest' =&gt; \\App\\Http\\Middleware\\RedirectIfAuthenticated::class, 'signed' =&gt; \\Illuminate\\Routing\\Middleware\\ValidateSignature::class, 'throttle' =&gt; \\Illuminate\\Routing\\Middleware\\ThrottleRequests::class, 'verified' =&gt; \\Illuminate\\Auth\\Middleware\\EnsureEmailIsVerified::class, 'jwt' =&gt; \\App\\Http\\Middleware\\Jwt::class,]; 3、在定义路由时应用中间件 routes/api.php 先定义一个路由组，然后对组应用 jwt 中间件，所有这个组中的路由都会先验证令牌 12345Route::middleware(['jwt'])-&gt;group(function () &#123; Route::post('orders', 'MemberController@order');&#125;); 4、控制器中获取令牌数据 因为在中间件中我们已经把解析令牌的数据保存到 Request 对象的 jwt 属性中了，所以在控制器中可以直接使用 $req-&gt;jwt 来获取令牌中的数据： 123456public function order(Request $req)&#123; // 获取令牌中的数据 echo $req-&gt;jwt-&gt;id;&#125; Postman 中设置令牌当使用 Postman 来请求需要验证的接口时，需要先在 Postman 中设置令牌，否则 会请求失败。 1、先使用正确的账号和密码登录成功得到一个令牌 2、把令牌保存到环境变量中 3、在需要令牌的接口上设置 authorzation 这时就可以正常的访问令牌了。","categories":[{"name":"Coding","slug":"Coding","permalink":"https://jiaobantang.github.io/categories/Coding/"},{"name":"PHP","slug":"Coding/PHP","permalink":"https://jiaobantang.github.io/categories/Coding/PHP/"}],"tags":[{"name":"服务端","slug":"服务端","permalink":"https://jiaobantang.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"},{"name":"接口开发","slug":"接口开发","permalink":"https://jiaobantang.github.io/tags/%E6%8E%A5%E5%8F%A3%E5%BC%80%E5%8F%91/"}]},{"title":"把可爱的看板娘捕捉到自己的hexo博客之血小板 (*^▽^*)","slug":"xuexiaoban","date":"2018-11-22T05:49:52.000Z","updated":"2020-01-03T08:25:57.948Z","comments":true,"path":"2018/11/22/xuexiaoban/","link":"","permalink":"https://jiaobantang.github.io/2018/11/22/xuexiaoban/","excerpt":"*瞧见血小板就莫名的开心( ＾∀＾） * 自娱的博客肯定也要让她来守护着。。。","text":"*瞧见血小板就莫名的开心( ＾∀＾） * 自娱的博客肯定也要让她来守护着。。。 准备工作首先你要去我的Github下载LIve2D代码，当然血小板的模型也包含在内。 正式开工接着解压复制live2d文件夹到你的hexo主题source目录下，拿我的material-x来说：如下图 然后在你博客程序头部文件（header）引入界面样式，在 head 标签内插入如下代码，目录为：Hexo\\themes\\material-x\\layout_partial\\head.ejs(还是拿我的博客主题举例) 1&lt;link rel=\"stylesheet\" href=\"/live2d/css/live2d.css\" /&gt; 接着在 body 标签内合适的位置插入 Live2D 看板娘的元素，按照 Html 书写规范写 ~我放在了博客footer文件里,目录：Hexo\\themes\\material-x\\layout_partial\\footer.ejs 123456&lt;!-- 血小板 --&gt; &lt;div id=\"landlord\"&gt; &lt;div class=\"message\" style=\"opacity:0\"&gt;&lt;/div&gt; &lt;canvas id=\"live2d\" width=\"560\" height=\"500\" class=\"live2d\"&gt;&lt;/canvas&gt; &lt;div class=\"hide-button\"&gt;隐藏&lt;/div&gt; &lt;/div&gt; 同样在你博客程序页脚文件（footer）引入脚本，目录：Hexo\\themes\\material-x\\layout_partial\\footer.ejs 1234567891011&lt;!-- live2d 血小板 --&gt;&lt;script type=\"text/javascript\" src=\"https://cdn.bootcss.com/jquery/2.2.4/jquery.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; var message_Path = '/live2d/' var home_Path = 'https://haremu.com/'&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"/live2d/js/live2d.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"/live2d/js/message.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; loadlive2d(\"live2d\", \"/live2d/model/xiaoban/model.json\");&lt;/script&gt; 然后输入以下指令 12hexo ghexo s 大功告成这时如果打开浏览器如果有血小板那就配置成功了，然后hexo d推到服务器上。打开你的博客就会出现可爱的血小板… 按着步骤来，怎么可能会出错! 鼠标放在页面某个元素上时，需要 Live2D 看板娘提示的请修改 message.json 文件。 示例： 123456789101112131415161718&#123; \"mouseover\": [ &#123; \"selector\": \".title a\", \"text\": [\"要看看 &#123;text&#125; 么？\"] &#125;, &#123; \"selector\": \".searchbox\", \"text\": [\"在找什么东西呢，需要帮忙吗？\"] &#125; ], \"click\": [ &#123; \"selector\": \"#landlord #live2d\", \"text\": [\"不要动手动脚的！快把手拿开~~\", \"真…真的是不知羞耻！\",\"Hentai！\", \"再摸的话我可要报警了！⌇●﹏●⌇\", \"110吗，这里有个变态一直在摸我(ó﹏ò｡)\"] &#125; ]&#125; 其他的自己研究去，反正我的血小板也是郁郁寡欢的，和我一样… 2019/2/21解决模糊问题当页面为手机时，适配效果在主题文件夹下找到_footer.less文件,添加以下样式 12345678910111213141516171819202122@media (max-width: @on_phone) &#123; #footer&#123; background-color:transparent; &#125; #landlord&#123; width: 200px; height: 170px; &#125; #live2d&#123; width: 200px; height: 170px; bottom: 0; &#125; .message&#123; width: 200px; left: 0px; &#125; #footer &#123; padding-bottom: 180px ; &#125;&#125;","categories":[{"name":"血小板","slug":"血小板","permalink":"https://jiaobantang.github.io/categories/%E8%A1%80%E5%B0%8F%E6%9D%BF/"}],"tags":[{"name":"live2D","slug":"live2D","permalink":"https://jiaobantang.github.io/tags/live2D/"},{"name":"血小板","slug":"血小板","permalink":"https://jiaobantang.github.io/tags/%E8%A1%80%E5%B0%8F%E6%9D%BF/"}]},{"title":"养育环境场","slug":"firstArtiscle","date":"2018-11-18T01:20:50.000Z","updated":"2020-01-03T08:56:17.393Z","comments":true,"path":"2018/11/18/firstArtiscle/","link":"","permalink":"https://jiaobantang.github.io/2018/11/18/firstArtiscle/","excerpt":"“场”其实是包含大量行为线索的环境，这写行为线索会刺激你做出特定的行为。就像到了班里就像学习，到了球场自然就想打球，而到了餐厅自然想吃饭一样。","text":"“场”其实是包含大量行为线索的环境，这写行为线索会刺激你做出特定的行为。就像到了班里就像学习，到了球场自然就想打球，而到了餐厅自然想吃饭一样。 生活的环境，就是”场”的环境。 因为场的不同，在某一些地方你会努力工作，而在另一个地方你会懈怠；在一些地方你会沉默不语，而在另一些地方你会滔滔不绝 就比如我来说，平常下晚自习，我会纠结于要不要带电脑回去，带吧又想玩，不带吧又想学习，于是乎我总喜欢把今天总结的东西放在印象笔记里。我回到寝室的情况是这样的： 回到寝室，坐在板凳上歇会，歇着歇着,就去刷知乎了； 该洗漱了，不情愿的离开手机去洗漱 等洗漱完了，今天知乎热榜还没刷呢，干脆待会刷完吧 也许你已经猜到了，我会不停地刷。一看表，已经很晚，快要睡觉了。一种虚度了时光的空虚感悄然来袭，让我感到泪丧。笔记还没看呢。。。 我经常睡得很晚。有人说：晚睡是因为我们不肯面对失败的一天就这么结束了。我也是也是这样。 “我现在明明因为熬夜搞的很焦虑，为什么还要这样日复一日，不能改变呢？” 陈海贤曾把生活的乐趣分为两种：消费型快乐和创造型快乐。在消费型快乐里，你消费的是别人创造的产品，满足的是表面上的感官刺激；而在创造型快乐里，你在创造自己的产品。你在发挥自己的才能，辛苦地工作。在这个过程中，你会体会到一种深刻的成就感，一种自己正在变得更好的感觉。如果说消费型快乐是酒肉朋友，那么创造型快乐就是良师益友。 学习是一种创造型快乐，而看刷知乎，当然是一种消费型快乐了。所以我体会到的，正是消费型快乐过后所产生的空虚感。可是，明明我们知道创造型快乐更好，却为什么不能从事创造型快乐呢？原因是：创造型快乐是骑象人所热衷的、理智的快乐；而消费型快乐是大象所热衷的、感官的快乐。如果要从消费型快乐转到创造型快乐，我们就需要说服感性的大象。给自己创造一个学习或者工作氛围浓厚的“场”，就是一个好办法。但是不幸，也许是因为太懂享受了，我在寝室所创造的“场”，是放松和娱乐的。那里所有的行为线索，都在暗示我：应该好好休息了。所以，我无法驱动大象去主动学习，就完全可以理解了。 讲到这里，我想对“场“做一个更精确的总结：所谓“场”，就是我们心中的一个关于“空间功能”的假设。在这个假设里，图书馆、自习室或者写字间是和工作学习相联系的；而家、宿舍是和休息娱乐相联系的。你到了被假设为工作场所的空间，自然就表现出工作的样子；反之，如果你在家或宿舍，要让自己好好工作，就要付出几倍的心理努力，也未必能够实现。 现在你知道了什么是“场”，也知道了“场“怎么影响我们的行为。接下来，我们就来讨论一下该怎么在生活中应用各种“场”。养一个自己的“场”，要想用好”场”，我们先要弄清“场”的力量到底从哪里来。“场”的第一个来源：别人在这个空间里的行为。人是一种社会性的动物，如果在一个空间里，别人都在埋头工作，它自然也会暗示你努力工作。很多人说，高中三年，是自己最努力的时光。那是因为每个人都在努力学习，让高光。那是因为每个人都在努力学习，让高中教室变成了一个很有力的场。他跟我们透露过，他这个课的内容，就是在他省图书馆的自习室里完成的。他家里有书房，为什么要每天到围书馆工作呢？就是因为这里学习的人多，”场”的力量比较强嘛。这个场景你当然懂，但不是那么好实现。如果每次都要到图书馆才能进入学习和创造的状态，那么对环境的要求也太高了。所以，我们要重点说说“场”的第二个力量来原了：你以的在这个空间里的行为。 陈海贤举个例子。陈海贤家里有一个书桌，在这个书桌上，他只做跟工作有关的事。如果写着写着，他想浏览网页或者看电影，他会要求自己换一个地方，比如到客厅的沙发上去。因为，如果他在这个书桌上娱乐，这个书桌作为工作的“场”就会被破坏掉。他还有另外一个工作场，就是他的电脑，事实上，他有两台电脑；一台普通电脑，一台工作电脑。工作电脑里，只有Office等一些用于工作的软件。当他打开工作电脑的时候，他心里的大象就已经做好了准备，他就知道要开始工作了。可是对大部分人来说，工作和娱乐的距离只有关闭Word和打开浏览器的距离，要抵制这样的诱感，就太难为大象了。所以，“场”这个东西并不玄虚。它就是你在一个空间里的做事习惯，习惯会形成稳定的心理预期，进而义会巩园习惯的行为。你在这个空间里做的事情越纯牌、越持久，这个空间“场”的力量就越大。 现在回到我身上我也应该给自己一个建议；像他一样，我也要找个地方养一个小小的、专门进行学习与工作的“场”。如果能在这个“场“里贴些激励自己的话，作为“场”的边界和线索，那就更有帮助了。这样，在那里那个纯粹的休闲“场“里，学习就抢占了一块自己的地盘，它的存在会给我强烈的心理略示，帮助我行动起来。而随着对这个“场”的使用越来越频繁，它也会变得越来越强大。听到这里，也许你想问：”场”只对学习和工作有用吗？当然不是，其实“场“可以巧妙地应用在各种改变的场景中。比如：在家庭治疗里，他也经常建议一些琦远的夫麦能在固定的时间，找一个固定的地点，做一些深入的沟通和交流。如果你经常感到疲意，可以给自己做一个“恢复精力”的场，比如：每天到一个固定的地方独处静坐，让自己恢复能量。 讲到这里，让我们再来深入思考一下，“场”到底是什么？ 他其实是环境记忆中，我们每个人的历史。 你的奋斗、你的挣扎、你的灵光一现、你的引以为豪，这些事在别人看来也许无足轻重，可是对你却意义重大。 如果你有意识地让它们只在某个特定的空间里发生，那这个空间就开始有了记忆，它就变成了能调动和激发大象的”场“，这里就成为了存储你美好的新经验的记忆银行。 参考文献:陈海贤《自我发展心理学》","categories":[{"name":"Self","slug":"Self","permalink":"https://jiaobantang.github.io/categories/Self/"}],"tags":[{"name":"自我发展","slug":"自我发展","permalink":"https://jiaobantang.github.io/tags/%E8%87%AA%E6%88%91%E5%8F%91%E5%B1%95/"},{"name":"改变","slug":"改变","permalink":"https://jiaobantang.github.io/tags/%E6%94%B9%E5%8F%98/"}]},{"title":"想给博主说点什么？","slug":"message","date":"2018-11-11T03:11:11.000Z","updated":"2019-03-05T13:02:31.810Z","comments":true,"path":"2018/11/11/message/","link":"","permalink":"https://jiaobantang.github.io/2018/11/11/message/","excerpt":"","text":"请在评论区写下想对我说的话","categories":[],"tags":[]}]}